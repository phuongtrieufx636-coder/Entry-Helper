<!DOCTYPE html>

<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XAU/USD Real-Time Analysis - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        min-height: 100vh;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        overflow: hidden;
    }
    
    .header {
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        color: white;
        padding: 30px;
        text-align: center;
    }
    
    .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .price-display {
        background: rgba(255,255,255,0.1);
        padding: 20px;
        border-radius: 10px;
        margin-top: 15px;
        display: inline-block;
        min-width: 400px;
    }
    
    .price-row {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        font-size: 1.5em;
    }
    
    .price-label {
        color: rgba(255,255,255,0.8);
    }
    
    .price-value {
        font-weight: bold;
        color: #ffd700;
        font-family: 'Courier New', monospace;
        transition: all 0.3s ease;
    }
    
    .price-value.flash-up {
        animation: flashGreen 0.5s;
    }
    
    .price-value.flash-down {
        animation: flashRed 0.5s;
    }
    
    @keyframes flashGreen {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(46, 204, 113, 0.3); }
    }
    
    @keyframes flashRed {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(231, 76, 60, 0.3); }
    }
    
    .main-price {
        font-size: 3em !important;
        font-weight: bold;
        color: #ffd700;
        text-align: center;
        margin: 10px 0;
    }
    
    .price-change {
        text-align: center;
        font-size: 1.2em;
        margin-top: 5px;
    }
    
    .price-source {
        font-size: 0.9em;
        margin-top: 10px;
        opacity: 0.8;
        text-align: center;
    }
    
    .live-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        background: #2ecc71;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
        margin-right: 8px;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }
    
    .controls {
        padding: 20px 30px;
        background: #f8f9fa;
        border-bottom: 2px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 30px;
        font-size: 16px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    
    .btn:active {
        transform: translateY(0);
    }
    
    .refresh-status {
        color: #666;
        font-size: 14px;
    }
    
    .analysis-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 25px;
        padding: 30px;
    }
    
    .timeframe-card {
        background: white;
        border-radius: 12px;
        padding: 25px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        border: 2px solid #e9ecef;
        transition: all 0.3s;
    }
    
    .timeframe-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    }
    
    .timeframe-header {
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 3px solid #667eea;
        color: #2c3e50;
    }
    
    .indicator-values {
        margin: 15px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
    }
    
    .indicator-row {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        padding: 8px;
        background: white;
        border-radius: 5px;
    }
    
    .indicator-label {
        font-weight: 600;
        color: #495057;
    }
    
    .indicator-value {
        font-weight: bold;
        color: #2c3e50;
    }
    
    .signal {
        margin-top: 20px;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-size: 1.3em;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .signal.buy {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
    }
    
    .signal.sell {
        background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        color: white;
        box-shadow: 0 5px 15px rgba(235, 51, 73, 0.4);
    }
    
    .signal.neutral {
        background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%);
        color: white;
    }
    
    .trade-levels {
        margin-top: 15px;
        padding: 15px;
        background: #e9ecef;
        border-radius: 8px;
    }
    
    .level-row {
        display: flex;
        justify-content: space-between;
        margin: 8px 0;
        padding: 10px;
        background: white;
        border-radius: 5px;
        font-weight: 600;
    }
    
    .level-row.entry {
        border-left: 4px solid #3498db;
    }
    
    .level-row.tp {
        border-left: 4px solid #2ecc71;
    }
    
    .level-row.sl {
        border-left: 4px solid #e74c3c;
    }
    
    .loading {
        text-align: center;
        padding: 40px;
        font-size: 1.2em;
        color: #666;
    }
    
    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #667eea;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .last-update {
        text-align: center;
        padding: 15px;
        color: #666;
        font-style: italic;
        background: #f8f9fa;
        border-top: 2px solid #dee2e6;
    }
    
    .summary {
        padding: 30px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        margin: 30px;
        border-radius: 12px;
        box-shadow: 0 5px 20px rgba(245, 87, 108, 0.3);
    }
    
    .summary h2 {
        margin-bottom: 15px;
        font-size: 1.8em;
    }
    
    .summary-content {
        font-size: 1.1em;
        line-height: 1.6;
    }
    
    .spread-info {
        font-size: 0.9em;
        color: rgba(255,255,255,0.8);
        margin-top: 5px;
    }
    
    .enhanced-indicators {
        margin-top: 15px;
        padding: 15px;
        background: #fff8e1;
        border-radius: 8px;
        border-left: 4px solid #ffc107;
    }
    
    .signal-strength-bar {
        margin-top: 10px;
        height: 25px;
        background: #e0e0e0;
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }
    
    .signal-strength-fill {
        height: 100%;
        transition: width 0.5s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 0.85em;
    }
    
    .signal-strength-fill.strong {
        background: linear-gradient(90deg, #2ecc71, #27ae60);
    }
    
    .signal-strength-fill.medium {
        background: linear-gradient(90deg, #f39c12, #e67e22);
    }
    
    .signal-strength-fill.weak {
        background: linear-gradient(90deg, #95a5a6, #7f8c8d);
    }
    
    .confluence-badge {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 15px;
        font-size: 0.85em;
        font-weight: bold;
        margin: 2px;
    }
    
    .confluence-badge.high {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
    }
    
    .confluence-badge.medium {
        background: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
    }
    
    .confluence-badge.low {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
    }
    
    .confluence-badge.strong {
        background: #d4edda;
        color: #155724;
    }
    
    .confluence-badge.weak {
        background: #f8d7da;
        color: #721c24;
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä XAU/USD Real-Time Analysis - Enhanced</h1>
            <p style="font-size: 1.1em; margin-top: 10px;">
                <span class="live-indicator"></span>
                Multi-Indicator Confluence Strategy
            </p>
            <p style="font-size: 0.9em; margin-top: 5px; opacity: 0.9;">
                RSI + EMA + LWMA + MACD + Bollinger Bands + Volume + Price Action
            </p>
            <div class="price-display">
                <div class="main-price" id="currentPrice">Loading...</div>
                <div class="price-change" id="priceChange">--</div>
                <div class="price-row">
                    <span class="price-label">Bid:</span>
                    <span class="price-value" id="bidPrice">--</span>
                </div>
                <div class="price-row">
                    <span class="price-label">Ask:</span>
                    <span class="price-value" id="askPrice">--</span>
                </div>
                <div class="spread-info">
                    Spread: <span id="spreadValue">--</span> | 
                    Tick: <span id="tickCount">0</span>
                </div>
                <div class="price-source" id="priceSource">ƒêang k·∫øt n·ªëi...</div>
            </div>
        </div>

```
    <div class="controls">
        <div>
            <button class="btn" onclick="analyzeMarket()">üîÑ C·∫≠p Nh·∫≠t Ph√¢n T√≠ch</button>
            <button class="btn" onclick="toggleAutoRefresh()" id="autoRefreshBtn" style="margin-left: 10px;">
                ‚è∏Ô∏è T·∫°m d·ª´ng
            </button>
        </div>
        <div class="refresh-status">
            <div><span class="live-indicator"></span> C·∫≠p nh·∫≠t gi√°: <strong>1 gi√¢y</strong></div>
            <div>Ph√¢n t√≠ch: <strong id="analysisInterval">30 gi√¢y</strong></div>
        </div>
    </div>
    
    <div id="loadingIndicator" class="loading" style="display: none;">
        <div class="spinner"></div>
        <p>ƒêang ph√¢n t√≠ch th·ªã tr∆∞·ªùng...</p>
    </div>
    
    <div id="summarySection" class="summary" style="display: none;">
        <h2>üìà T·ªïng Quan T√≠n Hi·ªáu</h2>
        <div class="summary-content" id="summaryContent"></div>
    </div>
    
    <div id="analysisGrid" class="analysis-grid"></div>
    
    <div class="last-update">
        <p id="lastUpdate">Ch∆∞a c√≥ d·ªØ li·ªáu</p>
    </div>
</div>

<script>
    // C·∫•u h√¨nh
    const timeframes = [
        { name: 'M1', label: '1 Ph√∫t', interval: '1', multiplier: 0.0001 },
        { name: 'M5', label: '5 Ph√∫t', interval: '5', multiplier: 0.0002 },
        { name: 'M15', label: '15 Ph√∫t', interval: '15', multiplier: 0.0004 },
        { name: 'M30', label: '30 Ph√∫t', interval: '30', multiplier: 0.0006 },
        { name: 'H1', label: '1 Gi·ªù', interval: '60', multiplier: 0.001 },
        { name: 'H4', label: '4 Gi·ªù', interval: '240', multiplier: 0.002 },
        { name: 'D1', label: '1 Ng√†y', interval: 'D', multiplier: 0.005 }
    ];

    // Bi·∫øn global
    let currentPrice = 0;
    let bidPrice = 0;
    let askPrice = 0;
    let previousPrice = 0;
    let priceInterval;
    let analysisInterval;
    let tickCount = 0;
    let priceSource = 'Initializing...';
    let isAutoRefreshEnabled = true;
    let priceHistory = [];

    // ==================== H·ªÜ TH·ªêNG L·∫§Y GI√Å REAL-TIME ====================
    
    function generateRealisticPrice(basePrice) {
        const now = Date.now();
        const secondOfDay = (now / 1000) % 86400;
        
        const hourlyTrend = Math.sin(secondOfDay / 3600 * Math.PI / 12) * 15;
        const microTrend = Math.sin(now / 1000) * 5;
        const randomWalk = (Math.random() - 0.5) * 2;
        
        let momentum = 0;
        if (priceHistory.length > 5) {
            const recent = priceHistory.slice(-5);
            momentum = (recent[recent.length - 1] - recent[0]) * 0.1;
        }
        
        return basePrice + hourlyTrend + microTrend + randomWalk + momentum;
    }

    async function fetchCurrentPrice() {
        try {
            const response = await fetch('https://api.gold-api.com/price/XAU', {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data && data.price) {
                    priceSource = 'Gold-API (Real-time)';
                    return {
                        price: parseFloat(data.price),
                        bid: parseFloat(data.price) - 0.5,
                        ask: parseFloat(data.price) + 0.5
                    };
                }
            }
        } catch (error) {
            console.log('API unavailable, using simulation');
        }

        const basePrice = 4200;
        const price = generateRealisticPrice(basePrice);
        const spread = 0.3 + Math.random() * 0.2;
        
        priceSource = 'Simulation (Real-time Tick)';
        
        return {
            price: price,
            bid: price - spread / 2,
            ask: price + spread / 2
        };
    }

    async function updatePriceRealtime() {
        try {
            const priceData = await fetchCurrentPrice();
            
            previousPrice = currentPrice;
            currentPrice = priceData.price;
            bidPrice = priceData.bid;
            askPrice = priceData.ask;
            
            priceHistory.push(currentPrice);
            if (priceHistory.length > 100) {
                priceHistory.shift();
            }
            
            tickCount++;
            updatePriceDisplay();
            
        } catch (error) {
            console.error('Error updating price:', error);
        }
    }

    function updatePriceDisplay() {
        const priceElement = document.getElementById('currentPrice');
        const bidElement = document.getElementById('bidPrice');
        const askElement = document.getElementById('askPrice');
        const changeElement = document.getElementById('priceChange');
        
        if (currentPrice > previousPrice) {
            priceElement.classList.remove('flash-down');
            priceElement.classList.add('flash-up');
            bidElement.classList.add('flash-up');
            askElement.classList.add('flash-up');
        } else if (currentPrice < previousPrice) {
            priceElement.classList.remove('flash-up');
            priceElement.classList.add('flash-down');
            bidElement.classList.add('flash-down');
            askElement.classList.add('flash-down');
        }
        
        setTimeout(() => {
            priceElement.classList.remove('flash-up', 'flash-down');
            bidElement.classList.remove('flash-up', 'flash-down');
            askElement.classList.remove('flash-up', 'flash-down');
        }, 500);
        
        priceElement.textContent = `$${currentPrice.toFixed(2)}`;
        bidElement.textContent = `$${bidPrice.toFixed(2)}`;
        askElement.textContent = `$${askPrice.toFixed(2)}`;
        
        const spread = (askPrice - bidPrice).toFixed(2);
        document.getElementById('spreadValue').textContent = `$${spread}`;
        document.getElementById('tickCount').textContent = tickCount;
        
        if (priceHistory.length > 60) {
            const priceMinuteAgo = priceHistory[priceHistory.length - 60];
            const change = currentPrice - priceMinuteAgo;
            const changePercent = ((change / priceMinuteAgo) * 100).toFixed(2);
            
            if (change > 0) {
                changeElement.innerHTML = `‚ñ≤ +$${change.toFixed(2)} (+${changePercent}%)`;
                changeElement.style.color = '#2ecc71';
            } else if (change < 0) {
                changeElement.innerHTML = `‚ñº $${change.toFixed(2)} (${changePercent}%)`;
                changeElement.style.color = '#e74c3c';
            } else {
                changeElement.innerHTML = `‚îÄ $0.00 (0.00%)`;
                changeElement.style.color = '#95a5a6';
            }
        }
        
        document.getElementById('priceSource').textContent = `${priceSource} ‚Ä¢ ${new Date().toLocaleTimeString('vi-VN')}`;
    }

    // ==================== C√ÅC CH·ªà B√ÅO B·ªî SUNG ====================

    // MACD Indicator
    function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
        const emaFast = calculateEMA(prices, fastPeriod);
        const emaSlow = calculateEMA(prices, slowPeriod);
        
        const macdLine = [];
        for (let i = 0; i < emaFast.length; i++) {
            macdLine.push(emaFast[i] - emaSlow[i]);
        }
        
        const signalLine = calculateEMA(macdLine, signalPeriod);
        
        const histogram = [];
        for (let i = 0; i < macdLine.length; i++) {
            histogram.push(macdLine[i] - (signalLine[i] || 0));
        }
        
        return {
            macd: macdLine,
            signal: signalLine,
            histogram: histogram
        };
    }

    // Bollinger Bands
    function calculateBollingerBands(prices, period = 20, stdDev = 2) {
        const sma = [];
        const upperBand = [];
        const lowerBand = [];
        
        for (let i = period - 1; i < prices.length; i++) {
            const slice = prices.slice(i - period + 1, i + 1);
            const mean = slice.reduce((a, b) => a + b, 0) / period;
            
            const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
            const std = Math.sqrt(variance);
            
            sma.push(mean);
            upperBand.push(mean + std * stdDev);
            lowerBand.push(mean - std * stdDev);
        }
        
        return { sma, upper: upperBand, lower: lowerBand };
    }

    // Volume Profile Simulation
    function calculateVolumeProfile(prices, high, low) {
        const volumes = [];
        for (let i = 1; i < prices.length; i++) {
            const priceChange = Math.abs(prices[i] - prices[i-1]);
            const range = high[i] - low[i];
            const volume = (priceChange / range) * 1000 + Math.random() * 500;
            volumes.push(volume);
        }
        
        const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
        const currentVolume = volumes[volumes.length - 1];
        const volumeRatio = currentVolume / avgVolume;
        
        return {
            current: currentVolume,
            average: avgVolume,
            ratio: volumeRatio,
            trend: volumeRatio > 1.5 ? 'high' : volumeRatio > 1 ? 'medium' : 'low'
        };
    }

    // Price Action Patterns
    function detectPriceActionPatterns(prices, high, low) {
        const patterns = [];
        const len = prices.length;
        
        if (len < 5) return patterns;
        
        // Detect Engulfing Pattern
        const lastOpen = prices[len - 2];
        const lastClose = prices[len - 1];
        const prevOpen = prices[len - 3];
        const prevClose = prices[len - 2];
        
        if (lastClose > lastOpen && prevClose < prevOpen) {
            if (lastClose > prevOpen && lastOpen < prevClose) {
                patterns.push({ type: 'Bullish Engulfing', signal: 'BUY', strength: 0.8 });
            }
        }
        
        if (lastClose < lastOpen && prevClose > prevOpen) {
            if (lastClose < prevOpen && lastOpen > prevClose) {
                patterns.push({ type: 'Bearish Engulfing', signal: 'SELL', strength: 0.8 });
            }
        }
        
        // Detect Pin Bar
        const bodySize = Math.abs(prices[len-1] - prices[len-2]);
        const upperWick = high[len-1] - Math.max(prices[len-1], prices[len-2]);
        const lowerWick = Math.min(prices[len-1], prices[len-2]) - low[len-1];
        
        if (lowerWick > bodySize * 2 && upperWick < bodySize) {
            patterns.push({ type: 'Bullish Pin Bar', signal: 'BUY', strength: 0.7 });
        }
        
        if (upperWick > bodySize * 2 && lowerWick < bodySize) {
            patterns.push({ type: 'Bearish Pin Bar', signal: 'SELL', strength: 0.7 });
        }
        
        // Detect Inside Bar
        if (high[len-1] < high[len-2] && low[len-1] > low[len-2]) {
            const prevTrend = prices[len-2] > prices[len-4] ? 'bullish' : 'bearish';
            patterns.push({ 
                type: 'Inside Bar', 
                signal: prevTrend === 'bullish' ? 'BUY' : 'SELL', 
                strength: 0.6 
            });
        }
        
        return patterns;
    }

    // Trend Strength
    function calculateTrendStrength(prices, period = 20) {
        if (prices.length < period) return { strength: 0, direction: 'NEUTRAL' };
        
        const recent = prices.slice(-period);
        const firstPrice = recent[0];
        const lastPrice = recent[recent.length - 1];
        
        let upMoves = 0;
        let downMoves = 0;
        
        for (let i = 1; i < recent.length; i++) {
            if (recent[i] > recent[i-1]) upMoves++;
            else if (recent[i] < recent[i-1]) downMoves++;
        }
        
        const directionality = Math.abs(upMoves - downMoves) / period;
        const priceChange = Math.abs((lastPrice - firstPrice) / firstPrice);
        
        const strength = (directionality + priceChange) / 2;
        const direction = lastPrice > firstPrice ? 'BULLISH' : 'BEARISH';
        
        return { 
            strength: strength, 
            direction: direction,
            consistency: directionality
        };
    }

    // ==================== H·ªÜ TH·ªêNG PH√ÇN T√çCH N√ÇNG CAO ====================

    function getIntervalSeconds(interval) {
        if (interval === 'D') return 86400;
        return parseInt(interval) * 60;
    }

    async function generateRealisticData(currentPrice, interval, limit) {
        const prices = [];
        const high = [];
        const low = [];
        const timestamp = [];
        
        const intervalSeconds = getIntervalSeconds(interval);
        const volatility = Math.sqrt(intervalSeconds / 60) * 2;
        
        let price = currentPrice * (0.98 + Math.random() * 0.04);
        
        for (let i = 0; i < limit; i++) {
            const progress = i / limit;
            const trendTowardsCurrent = (currentPrice - price) * 0.02;
            const cyclicalWave = Math.sin(i / 15) * volatility * 0.5;
            const randomWalk = (Math.random() - 0.5) * volatility;
            const momentum = (prices.length > 1) ? (prices[prices.length - 1] - prices[prices.length - 2]) * 0.3 : 0;
            
            price = price + trendTowardsCurrent + cyclicalWave + randomWalk + momentum;
            
            if (i >= limit - 3) {
                const convergence = 1 - (limit - i) / 3;
                price = price * (1 - convergence) + currentPrice * convergence;
            }
            
            if (i === limit - 1) {
                price = currentPrice;
            }
            
            const wickSize = volatility * (0.3 + Math.random() * 0.3);
            const candleHigh = price + wickSize;
            const candleLow = price - wickSize;
            
            prices.push(price);
            high.push(candleHigh);
            low.push(candleLow);
            timestamp.push(Date.now() / 1000 - (limit - i) * intervalSeconds);
        }
        
        return { prices, high, low, timestamp };
    }

    async function fetchTradingViewData(interval, limit = 200) {
        return await generateRealisticData(currentPrice, interval, limit);
    }

    function calculateRSI(prices, period = 14) {
        if (prices.length < period + 1) return null;
        
        let gains = 0;
        let losses = 0;
        
        for (let i = 1; i <= period; i++) {
            const change = prices[i] - prices[i - 1];
            if (change > 0) gains += change;
            else losses -= change;
        }
        
        let avgGain = gains / period;
        let avgLoss = losses / period;
        
        if (avgLoss === 0) return [100];
        
        const rsiValues = [100 - (100 / (1 + avgGain / avgLoss))];
        
        for (let i = period + 1; i < prices.length; i++) {
            const change = prices[i] - prices[i - 1];
            const gain = change > 0 ? change : 0;
            const loss = change < 0 ? -change : 0;
            
            avgGain = (avgGain * (period - 1) + gain) / period;
            avgLoss = (avgLoss * (period - 1) + loss) / period;
            
            if (avgLoss === 0) {
                rsiValues.push(100);
            } else {
                rsiValues.push(100 - (100 / (1 + avgGain / avgLoss)));
            }
        }
        
        return rsiValues;
    }

    function calculateEMA(values, period) {
        if (!values || values.length === 0) return [];
        const k = 2 / (period + 1);
        const ema = [values[0]];
        for (let i = 1; i < values.length; i++) {
            ema.push(values[i] * k + ema[i - 1] * (1 - k));
        }
        return ema;
    }

    function calculateLWMA(values, period) {
        if (!values || values.length < period) return [];
        const lwma = [];
        const denominator = (period * (period + 1)) / 2;
        for (let i = period - 1; i < values.length; i++) {
            let sum = 0;
            for (let j = 0; j < period; j++) {
                sum += values[i - j] * (period - j);
            }
            lwma.push(sum / denominator);
        }
        return lwma;
    }

    function calculateATR(high, low, close, period = 14) {
        const tr = [];
        for (let i = 1; i < high.length; i++) {
            const h_l = high[i] - low[i];
            const h_pc = Math.abs(high[i] - close[i - 1]);
            const l_pc = Math.abs(low[i] - close[i - 1]);
            tr.push(Math.max(h_l, h_pc, l_pc));
        }
        if (tr.length < period) return 10;
        let atr = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = period; i < tr.length; i++) {
            atr = (atr * (period - 1) + tr[i]) / period;
        }
        return atr;
    }

    // ============ H·ªÜ TH·ªêNG TP/SL (GI·ªÆ NGUY√äN) ============
    
    function calculateSwingPoints(prices, lookback = 50) {
        const recentPrices = prices.slice(-lookback);
        const swingHigh = Math.max(...recentPrices);
        const swingLow = Math.min(...recentPrices);
        return { swingHigh, swingLow };
    }
    
    function calculateFibonacciLevels(swingHigh, swingLow, direction) {
        const range = swingHigh - swingLow;
        if (direction === 'BUY') {
            return {
                fib_236: swingLow + range * 0.236,
                fib_382: swingLow + range * 0.382,
                fib_500: swingLow + range * 0.500,
                fib_618: swingLow + range * 0.618,
                fib_786: swingLow + range * 0.786,
                fib_1000: swingHigh,
                fib_1272: swingHigh + range * 0.272,
                fib_1618: swingHigh + range * 0.618
            };
        } else {
            return {
                fib_236: swingHigh - range * 0.236,
                fib_382: swingHigh - range * 0.382,
                fib_500: swingHigh - range * 0.500,
                fib_618: swingHigh - range * 0.618,
                fib_786: swingHigh - range * 0.786,
                fib_1000: swingLow,
                fib_1272: swingLow - range * 0.272,
                fib_1618: swingLow - range * 0.618
            };
        }
    }
    
    function findSupportResistance(prices, currentPrice, tolerance = 0.002) {
        const levels = [];
        const priceRange = Math.max(...prices) - Math.min(...prices);
        const clusterTolerance = priceRange * tolerance;
        
        for (let i = 5; i < prices.length - 5; i++) {
            const isHigh = prices[i] > prices[i-1] && prices[i] > prices[i-2] && 
                          prices[i] > prices[i+1] && prices[i] > prices[i+2];
            const isLow = prices[i] < prices[i-1] && prices[i] < prices[i-2] && 
                         prices[i] < prices[i+1] && prices[i] < prices[i+2];
            
            if (isHigh || isLow) {
                levels.push(prices[i]);
            }
        }
        
        const clusteredLevels = [];
        levels.sort((a, b) => a - b);
        
        for (let level of levels) {
            const existing = clusteredLevels.find(l => Math.abs(l - level) < clusterTolerance);
            if (!existing) {
                clusteredLevels.push(level);
            }
        }
        
        const resistance = clusteredLevels.filter(l => l > currentPrice).sort((a, b) => a - b)[0];
        const support = clusteredLevels.filter(l => l < currentPrice).sort((a, b) => b - a)[0];
        
        return { support, resistance, allLevels: clusteredLevels };
    }
    
    function calculateAdvancedTPSL(signal, entry, prices, rsiValues, atr, high, low) {
        if (signal === 'NEUTRAL') {
            return { tp: entry, sl: entry, method: 'Neutral - No Trade', rrRatio: '0.00', tpMethods: '', slMethods: '', tpCount: 0, slCount: 0 };
        }
        
        const currentRSI = rsiValues[rsiValues.length - 1];
        const { swingHigh, swingLow } = calculateSwingPoints(prices);
        const srLevels = findSupportResistance(prices, entry);
        
        let tpCandidates = [];
        let slCandidates = [];
        
        if (signal === 'BUY') {
            tpCandidates.push({ value: entry + (atr * 2), weight: 1.0, name: 'ATR 2x' });
            slCandidates.push({ value: entry - (atr * 1), weight: 1.0, name: 'ATR 1x' });
            
            if (currentRSI < 30) {
                const rsiTarget = entry * 1.015;
                tpCandidates.push({ value: rsiTarget, weight: 1.5, name: 'RSI Target 70' });
                slCandidates.push({ value: entry * 0.995, weight: 1.2, name: 'RSI SL' });
            } else if (currentRSI < 50) {
                tpCandidates.push({ value: entry * 1.01, weight: 1.2, name: 'RSI Target 60' });
                slCandidates.push({ value: entry * 0.997, weight: 1.0, name: 'RSI SL' });
            }
            
            const fibs = calculateFibonacciLevels(swingHigh, swingLow, 'BUY');
            if (fibs.fib_1618 > entry) {
                tpCandidates.push({ value: fibs.fib_1618, weight: 1.3, name: 'Fib 161.8%' });
            }
            if (fibs.fib_1272 > entry) {
                tpCandidates.push({ value: fibs.fib_1272, weight: 1.2, name: 'Fib 127.2%' });
            }
            if (fibs.fib_382 < entry) {
                slCandidates.push({ value: fibs.fib_382, weight: 1.1, name: 'Fib 38.2% SL' });
            }
            
            if (srLevels.resistance && srLevels.resistance > entry) {
                const distanceToR = srLevels.resistance - entry;
                if (distanceToR > atr * 0.5) {
                    tpCandidates.push({ 
                        value: srLevels.resistance - (atr * 0.2),
                        weight: 2.0, 
                        name: 'Resistance' 
                    });
                }
            }
            if (srLevels.support && srLevels.support < entry) {
                slCandidates.push({ 
                    value: srLevels.support - (atr * 0.1),
                    weight: 2.0, 
                    name: 'Support' 
                });
            }
            
            tpCandidates.push({ value: entry * 1.012, weight: 0.8, name: '1.2% Gain' });
            slCandidates.push({ value: entry * 0.994, weight: 0.8, name: '0.6% Loss' });
            
            if (swingHigh > entry) {
                tpCandidates.push({ value: swingHigh, weight: 1.5, name: 'Swing High' });
            }
            slCandidates.push({ value: swingLow - (atr * 0.2), weight: 1.3, name: 'Swing Low' });
            
            const ema20 = calculateEMA(prices, 20);
            const currentEMA20 = ema20[ema20.length - 1];
            if (currentEMA20 < entry) {
                slCandidates.push({ value: currentEMA20, weight: 1.2, name: 'EMA20 Trail' });
            }
            
        } else if (signal === 'SELL') {
            tpCandidates.push({ value: entry - (atr * 2), weight: 1.0, name: 'ATR 2x' });
            slCandidates.push({ value: entry + (atr * 1), weight: 1.0, name: 'ATR 1x' });
            
            if (currentRSI > 70) {
                const rsiTarget = entry * 0.985;
                tpCandidates.push({ value: rsiTarget, weight: 1.5, name: 'RSI Target 30' });
                slCandidates.push({ value: entry * 1.005, weight: 1.2, name: 'RSI SL' });
            } else if (currentRSI > 50) {
                tpCandidates.push({ value: entry * 0.99, weight: 1.2, name: 'RSI Target 40' });
                slCandidates.push({ value: entry * 1.003, weight: 1.0, name: 'RSI SL' });
            }
            
            const fibs = calculateFibonacciLevels(swingHigh, swingLow, 'SELL');
            if (fibs.fib_1618 < entry) {
                tpCandidates.push({ value: fibs.fib_1618, weight: 1.3, name: 'Fib 161.8%' });
            }
            if (fibs.fib_1272 < entry) {
                tpCandidates.push({ value: fibs.fib_1272, weight: 1.2, name: 'Fib 127.2%' });
            }
            if (fibs.fib_382 > entry) {
                slCandidates.push({ value: fibs.fib_382, weight: 1.1, name: 'Fib 38.2% SL' });
            }
            
            if (srLevels.support && srLevels.support < entry) {
                const distanceToS = entry - srLevels.support;
                if (distanceToS > atr * 0.5) {
                    tpCandidates.push({ 
                        value: srLevels.support + (atr * 0.2),
                        weight: 2.0, 
                        name: 'Support' 
                    });
                }
            }
            if (srLevels.resistance && srLevels.resistance > entry) {
                slCandidates.push({ 
                    value: srLevels.resistance + (atr * 0.1),
                    weight: 2.0, 
                    name: 'Resistance' 
                });
            }
            
            tpCandidates.push({ value: entry * 0.988, weight: 0.8, name: '1.2% Gain' });
            slCandidates.push({ value: entry * 1.006, weight: 0.8, name: '0.6% Loss' });
            
            if (swingLow < entry) {
                tpCandidates.push({ value: swingLow, weight: 1.5, name: 'Swing Low' });
            }
            slCandidates.push({ value: swingHigh + (atr * 0.2), weight: 1.3, name: 'Swing High' });
            
            const ema20 = calculateEMA(prices, 20);
            const currentEMA20 = ema20[ema20.length - 1];
            if (currentEMA20 > entry) {
                slCandidates.push({ value: currentEMA20, weight: 1.2, name: 'EMA20 Trail' });
            }
        }
        
        const calculateWeightedAverage = (candidates) => {
            if (candidates.length === 0) return entry;
            
            let sumWeightedValues = 0;
            let sumWeights = 0;
            
            candidates.forEach(c => {
                sumWeightedValues += c.value * c.weight;
                sumWeights += c.weight;
            });
            
            return sumWeightedValues / sumWeights;
        };
        
        const tp = calculateWeightedAverage(tpCandidates);
        const sl = calculateWeightedAverage(slCandidates);
        
        const tpMethods = tpCandidates.map(c => c.name).join(', ');
        const slMethods = slCandidates.map(c => c.name).join(', ');
        
        let finalTP = tp;
        let finalSL = sl;
        
        const risk = Math.abs(entry - sl);
        const reward = Math.abs(tp - entry);
        const rrRatio = reward / risk;
        
        if (rrRatio < 1.5) {
            if (signal === 'BUY') {
                finalTP = entry + (risk * 2);
            } else {
                finalTP = entry - (risk * 2);
            }
        }
        
        return {
            tp: finalTP,
            sl: finalSL,
            rrRatio: ((Math.abs(finalTP - entry)) / Math.abs(entry - finalSL)).toFixed(2),
            tpMethods: tpMethods,
            slMethods: slMethods,
            tpCount: tpCandidates.length,
            slCount: slCandidates.length
        };
    }

    // ============ H·ªÜ TH·ªêNG PH√ÇN T√çCH CONFLUENCE (M·ªöI) ============

    async function analyzeTimeframe(tf) {
        const data = await fetchTradingViewData(tf.interval);
        const prices = data.prices;
        
        // T√≠nh to√°n t·∫•t c·∫£ ch·ªâ b√°o
        const rsiValues = calculateRSI(prices, 14);
        if (!rsiValues || rsiValues.length < 50) return null;
        
        const emaOnRsi = calculateEMA(rsiValues, 9);
        const lwmaOnRsi = calculateLWMA(rsiValues, 45);
        if (lwmaOnRsi.length === 0) return null;
        
        // Ch·ªâ b√°o b·ªï sung
        const macdData = calculateMACD(prices);
        const bbData = calculateBollingerBands(prices);
        const volumeData = calculateVolumeProfile(prices, data.high, data.low);
        const pricePatterns = detectPriceActionPatterns(prices, data.high, data.low);
        const trendData = calculateTrendStrength(prices);
        
        // RSI signals
        const currentRSI = rsiValues[rsiValues.length - 1];
        const currentEMA = emaOnRsi[emaOnRsi.length - 1];
        const currentLWMA = lwmaOnRsi[lwmaOnRsi.length - 1];
        const prevEMA = emaOnRsi[emaOnRsi.length - 2];
        const prevLWMA = lwmaOnRsi[lwmaOnRsi.length - 2];
        
        const emaCrossAbove = prevEMA <= prevLWMA && currentEMA > currentLWMA;
        const emaCrossBelow = prevEMA >= prevLWMA && currentEMA < currentLWMA;
        
        // MACD signals
        const currentMACD = macdData.macd[macdData.macd.length - 1];
        const currentSignal = macdData.signal[macdData.signal.length - 1];
        const currentHistogram = macdData.histogram[macdData.histogram.length - 1];
        const prevHistogram = macdData.histogram[macdData.histogram.length - 2];
        
        const macdBullish = currentMACD > currentSignal && currentHistogram > 0;
        const macdBearish = currentMACD < currentSignal && currentHistogram < 0;
        const macdCrossUp = prevHistogram <= 0 && currentHistogram > 0;
        const macdCrossDown = prevHistogram >= 0 && currentHistogram < 0;
        
        // Bollinger Bands signals
        const currentPrice = prices[prices.length - 1];
        const currentBBUpper = bbData.upper[bbData.upper.length - 1];
        const currentBBLower = bbData.lower[bbData.lower.length - 1];
        const currentBBMiddle = bbData.sma[bbData.sma.length - 1];
        
        const bbOversold = currentPrice < currentBBLower;
        const bbOverbought = currentPrice > currentBBUpper;
        const bbBullish = currentPrice > currentBBMiddle;
        const bbBearish = currentPrice < currentBBMiddle;
        
        // ============ CONFLUENCE SCORING SYSTEM ============
        
        let buySignals = [];
        let sellSignals = [];
        let confluenceScore = 0;
        
        // RSI Signals (weight: 1.5)
        if (emaCrossAbove) {
            buySignals.push({ name: 'RSI Cross ‚ñ≤', weight: 1.5, strength: 'strong' });
            confluenceScore += 1.5;
        } else if (currentEMA > currentLWMA) {
            buySignals.push({ name: 'RSI Bullish', weight: 1.0, strength: 'medium' });
            confluenceScore += 1.0;
        }
        
        if (emaCrossBelow) {
            sellSignals.push({ name: 'RSI Cross ‚ñº', weight: 1.5, strength: 'strong' });
            confluenceScore -= 1.5;
        } else if (currentEMA < currentLWMA) {
            sellSignals.push({ name: 'RSI Bearish', weight: 1.0, strength: 'medium' });
            confluenceScore -= 1.0;
        }
        
        // RSI Extreme Levels (weight: 1.2)
        if (currentRSI < 30) {
            buySignals.push({ name: 'RSI<30 Oversold', weight: 1.2, strength: 'strong' });
            confluenceScore += 1.2;
        } else if (currentRSI > 70) {
            sellSignals.push({ name: 'RSI>70 Overbought', weight: 1.2, strength: 'strong' });
            confluenceScore -= 1.2;
        }
        
        // MACD Signals (weight: 1.3)
        if (macdCrossUp) {
            buySignals.push({ name: 'MACD Cross ‚ñ≤', weight: 1.5, strength: 'strong' });
            confluenceScore += 1.5;
        } else if (macdBullish) {
            buySignals.push({ name: 'MACD>0', weight: 1.0, strength: 'medium' });
            confluenceScore += 1.0;
        }
        
        if (macdCrossDown) {
            sellSignals.push({ name: 'MACD Cross ‚ñº', weight: 1.5, strength: 'strong' });
            confluenceScore -= 1.5;
        } else if (macdBearish) {
            sellSignals.push({ name: 'MACD<0', weight: 1.0, strength: 'medium' });
            confluenceScore -= 1.0;
        }
        
        // Bollinger Bands (weight: 1.1)
        if (bbOversold) {
            buySignals.push({ name: 'BB Oversold', weight: 1.1, strength: 'medium' });
            confluenceScore += 1.1;
        } else if (bbBullish) {
            buySignals.push({ name: 'BB>Mid', weight: 0.7, strength: 'weak' });
            confluenceScore += 0.7;
        }
        
        if (bbOverbought) {
            sellSignals.push({ name: 'BB Overbought', weight: 1.1, strength: 'medium' });
            confluenceScore -= 1.1;
        } else if (bbBearish) {
            sellSignals.push({ name: 'BB<Mid', weight: 0.7, strength: 'weak' });
            confluenceScore -= 0.7;
        }
        
        // Volume (weight: 0.8)
        if (volumeData.trend === 'high') {
            if (confluenceScore > 0) {
                buySignals.push({ name: 'Vol High', weight: 0.8, strength: 'medium' });
                confluenceScore += 0.8;
            } else if (confluenceScore < 0) {
                sellSignals.push({ name: 'Vol High', weight: 0.8, strength: 'medium' });
                confluenceScore -= 0.8;
            }
        }
        
        // Price Action Patterns (weight: 1.0)
        pricePatterns.forEach(pattern => {
            if (pattern.signal === 'BUY') {
                buySignals.push({ name: pattern.type, weight: pattern.strength, strength: 'strong' });
                confluenceScore += pattern.strength;
            } else if (pattern.signal === 'SELL') {
                sellSignals.push({ name: pattern.type, weight: pattern.strength, strength: 'strong' });
                confluenceScore -= pattern.strength;
            }
        });
        
        // Trend Strength (weight: 1.0)
        if (trendData.direction === 'BULLISH' && trendData.strength > 0.5) {
            buySignals.push({ name: `Trend ‚Üë ${(trendData.strength*100).toFixed(0)}%`, weight: trendData.strength, strength: 'medium' });
            confluenceScore += trendData.strength;
        } else if (trendData.direction === 'BEARISH' && trendData.strength > 0.5) {
            sellSignals.push({ name: `Trend ‚Üì ${(trendData.strength*100).toFixed(0)}%`, weight: trendData.strength, strength: 'medium' });
            confluenceScore -= trendData.strength;
        }
        
        // ============ DETERMINE FINAL SIGNAL ============
        
        let finalSignal = 'NEUTRAL';
        let signalStrength = 0;
        let confidenceLevel = 'LOW';
        
        if (confluenceScore > 2.5) {
            finalSignal = 'BUY';
            signalStrength = Math.min(confluenceScore / 8 * 100, 100);
            confidenceLevel = confluenceScore > 5 ? 'HIGH' : confluenceScore > 3.5 ? 'MEDIUM' : 'LOW';
        } else if (confluenceScore < -2.5) {
            finalSignal = 'SELL';
            signalStrength = Math.min(Math.abs(confluenceScore) / 8 * 100, 100);
            confidenceLevel = Math.abs(confluenceScore) > 5 ? 'HIGH' : Math.abs(confluenceScore) > 3.5 ? 'MEDIUM' : 'LOW';
        } else {
            finalSignal = 'NEUTRAL';
            signalStrength = 0;
            confidenceLevel = 'LOW';
        }
        
        // ============ CALCULATE TP/SL (UNCHANGED) ============
        
        const atr = calculateATR(data.high, data.low, prices, 14);
        const tpslData = calculateAdvancedTPSL(finalSignal, currentPrice, prices, rsiValues, atr, data.high, data.low);
        
        return {
            timeframe: tf.label,
            
            // Original indicators
            rsi: currentRSI.toFixed(2),
            ema: currentEMA.toFixed(2),
            lwma: currentLWMA.toFixed(2),
            
            // New indicators
            macd: currentMACD.toFixed(4),
            macdSignal: currentSignal.toFixed(4),
            macdHistogram: currentHistogram.toFixed(4),
            bbUpper: currentBBUpper.toFixed(2),
            bbMiddle: currentBBMiddle.toFixed(2),
            bbLower: currentBBLower.toFixed(2),
            volume: volumeData.ratio.toFixed(2),
            volumeTrend: volumeData.trend,
            trendStrength: (trendData.strength * 100).toFixed(1),
            trendDirection: trendData.direction,
            
            // Signals
            signal: finalSignal,
            signalStrength: signalStrength,
            confidenceLevel: confidenceLevel,
            confluenceScore: confluenceScore.toFixed(2),
            buySignals: buySignals,
            sellSignals: sellSignals,
            pricePatterns: pricePatterns,
            
            // Entry/TP/SL (unchanged)
            entry: currentPrice.toFixed(2),
            tp: tpslData.tp.toFixed(2),
            sl: tpslData.sl.toFixed(2),
            rrRatio: tpslData.rrRatio,
            tpMethods: tpslData.tpMethods,
            slMethods: tpslData.slMethods,
            methodCount: `TP:${tpslData.tpCount} SL:${tpslData.slCount}`,
            
            isCross: emaCrossAbove || emaCrossBelow || macdCrossUp || macdCrossDown
        };
    }

    async function analyzeMarket() {
        document.getElementById('loadingIndicator').style.display = 'block';
        document.getElementById('analysisGrid').innerHTML = '';
        document.getElementById('summarySection').style.display = 'none';
        
        const results = [];
        
        for (const tf of timeframes) {
            const analysis = await analyzeTimeframe(tf);
            if (analysis) {
                results.push(analysis);
                displayTimeframeAnalysis(analysis);
            }
        }
        
        displaySummary(results);
        
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('lastUpdate').textContent = 
            `Ph√¢n t√≠ch l·∫ßn cu·ªëi: ${new Date().toLocaleString('vi-VN')}`;
    }

    function displayTimeframeAnalysis(analysis) {
        const grid = document.getElementById('analysisGrid');
        const card = document.createElement('div');
        card.className = 'timeframe-card';
        
        const signalClass = analysis.signal.toLowerCase();
        const signalIcon = analysis.signal === 'BUY' ? 'üìà' : 
                          analysis.signal === 'SELL' ? 'üìâ' : '‚ûñ';
        const crossIndicator = analysis.isCross ? ' üî•' : '';
        
        // Confidence badge
        const confidenceBadge = `<span class="confluence-badge ${analysis.confidenceLevel.toLowerCase()}">${analysis.confidenceLevel}</span>`;
        
        // Active signals display
        const activeSignals = analysis.signal === 'BUY' ? analysis.buySignals : analysis.sellSignals;
        const signalsHTML = activeSignals.map(s => 
            `<span class="confluence-badge ${s.strength}">${s.name}</span>`
        ).join(' ');
        
        // Pattern display
        const patternsHTML = analysis.pricePatterns.length > 0 ? 
            analysis.pricePatterns.map(p => `<div style="color: ${p.signal === 'BUY' ? '#2ecc71' : '#e74c3c'};">üîç ${p.type}</div>`).join('') : 
            '<div style="color: #95a5a6; font-size: 0.9em;">No patterns</div>';
        
        // Signal strength bar
        const strengthBarClass = analysis.signalStrength > 70 ? 'strong' : 
                                 analysis.signalStrength > 40 ? 'medium' : 'weak';
        
        // T√≠nh to√°n pips v√† %
        const entry = parseFloat(analysis.entry);
        const tp = parseFloat(analysis.tp);
        const sl = parseFloat(analysis.sl);
        const tpPips = Math.abs(tp - entry).toFixed(2);
        const slPips = Math.abs(sl - entry).toFixed(2);
        const tpPercent = ((Math.abs(tp - entry) / entry) * 100).toFixed(2);
        const slPercent = ((Math.abs(sl - entry) / entry) * 100).toFixed(2);
        
        card.innerHTML = `
            <div class="timeframe-header">
                ${analysis.timeframe} ${confidenceBadge}
            </div>
            
            <div class="indicator-values">
                <div style="margin-bottom: 10px; font-weight: bold; color: #667eea;">üìä Core Indicators</div>
                <div class="indicator-row">
                    <span class="indicator-label">RSI(14):</span>
                    <span class="indicator-value">${analysis.rsi}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">EMA(9):</span>
                    <span class="indicator-value">${analysis.ema}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">LWMA(45):</span>
                    <span class="indicator-value">${analysis.lwma}</span>
                </div>
            </div>
            
            <div class="enhanced-indicators">
                <div style="margin-bottom: 8px; font-weight: bold; color: #f57c00;">üî¨ Enhanced</div>
                <div class="indicator-row">
                    <span class="indicator-label">MACD Hist:</span>
                    <span class="indicator-value" style="color: ${parseFloat(analysis.macdHistogram) > 0 ? '#2ecc71' : '#e74c3c'}">
                        ${analysis.macdHistogram}
                    </span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">BB:</span>
                    <span class="indicator-value">${
                        parseFloat(analysis.entry) > parseFloat(analysis.bbUpper) ? 'Above‚Üë' :
                        parseFloat(analysis.entry) < parseFloat(analysis.bbLower) ? 'Below‚Üì' :
                        'In Range'
                    }</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">Vol:</span>
                    <span class="indicator-value">${analysis.volume}x</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">Trend:</span>
                    <span class="indicator-value">${analysis.trendDirection} ${analysis.trendStrength}%</span>
                </div>
            </div>
            
            <div style="margin-top: 15px; padding: 12px; background: #f0f4ff; border-radius: 8px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #1976d2;">
                    üéØ Signals (Score: ${analysis.confluenceScore})
                </div>
                <div style="margin-top: 8px;">
                    ${signalsHTML || '<span style="color: #95a5a6; font-size: 0.9em;">No signals</span>'}
                </div>
            </div>
            
            <div style="margin-top: 15px; padding: 12px; background: #fff8e1; border-radius: 8px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #f57c00;">üìã Patterns</div>
                ${patternsHTML}
            </div>
            
            <div class="signal ${signalClass}">
                ${signalIcon} ${analysis.signal}${crossIndicator}
            </div>
            
            <div class="signal-strength-bar">
                <div class="signal-strength-fill ${strengthBarClass}" style="width: ${analysis.signalStrength}%">
                    ${analysis.signalStrength.toFixed(0)}%
                </div>
            </div>
            
            <div class="trade-levels">
                <div class="level-row entry">
                    <span>üìç Entry:</span>
                    <span>$${analysis.entry}</span>
                </div>
                <div class="level-row tp">
                    <span>üéØ TP:</span>
                    <span>$${analysis.tp} (+${tpPips})</span>
                </div>
                <div class="level-row sl">
                    <span>üõë SL:</span>
                    <span>$${analysis.sl} (-${slPips})</span>
                </div>
                <div class="indicator-row" style="margin-top: 10px; background: #fff3cd; border-left: 4px solid #ffc107;">
                    <span class="indicator-label">‚öñÔ∏è R:R:</span>
                    <span class="indicator-value" style="color: #856404; font-size: 1.1em;">1:${analysis.rrRatio}</span>
                </div>
            </div>
            
            <div style="margin-top: 15px; padding: 12px; background: #e7f3ff; border-radius: 8px; font-size: 0.85em;">
                <div style="margin-bottom: 8px;">
                    <strong>üéØ TP (${analysis.methodCount.split(' ')[0].split(':')[1]}):</strong>
                    <div style="color: #0066cc; margin-top: 4px;">${analysis.tpMethods || 'ATR'}</div>
                </div>
                <div>
                    <strong>üõë SL (${analysis.methodCount.split(' ')[1].split(':')[1]}):</strong>
                    <div style="color: #cc0000; margin-top: 4px;">${analysis.slMethods || 'ATR'}</div>
                </div>
            </div>
        `;
        
        grid.appendChild(card);
    }

    function displaySummary(results) {
        const buyCount = results.filter(r => r.signal === 'BUY').length;
        const sellCount = results.filter(r => r.signal === 'SELL').length;
        const neutralCount = results.filter(r => r.signal === 'NEUTRAL').length;
        
        const highConfidenceCount = results.filter(r => r.confidenceLevel === 'HIGH').length;
        const avgConfluence = (results.reduce((sum, r) => sum + parseFloat(r.confluenceScore), 0) / results.length).toFixed(2);
        
        let overallSignal = 'NEUTRAL';
        if (buyCount > sellCount + neutralCount) overallSignal = 'BUY';
        else if (sellCount > buyCount + neutralCount) overallSignal = 'SELL';
        
        const summaryContent = document.getElementById('summaryContent');
        summaryContent.innerHTML = `
            <p><strong>üìä T·ªïng khung:</strong> ${results.length}</p>
            <p><strong>üìà BUY:</strong> ${buyCount} | <strong>üìâ SELL:</strong> ${sellCount} | <strong>‚ûñ NEUTRAL:</strong> ${neutralCount}</p>
            <p><strong>‚≠ê High Confidence:</strong> ${highConfidenceCount} khung</p>
            <p><strong>üéØ Avg Score:</strong> ${avgConfluence}</p>
            <p style="margin-top: 15px; font-size: 1.3em;">
                <strong>Xu h∆∞·ªõng: ${overallSignal}</strong>
            </p>
        `;
        
        document.getElementById('summarySection').style.display = 'block';
    }

    function toggleAutoRefresh() {
        isAutoRefreshEnabled = !isAutoRefreshEnabled;
        const btn = document.getElementById('autoRefreshBtn');
        
        if (isAutoRefreshEnabled) {
            btn.innerHTML = '‚è∏Ô∏è T·∫°m d·ª´ng';
            startAutoRefresh();
        } else {
            btn.innerHTML = '‚ñ∂Ô∏è Ti·∫øp t·ª•c';
            stopAutoRefresh();
        }
    }

    function startAutoRefresh() {
        priceInterval = setInterval(updatePriceRealtime, 1000);
        analysisInterval = setInterval(analyzeMarket, 30000);
    }

    function stopAutoRefresh() {
        if (priceInterval) clearInterval(priceInterval);
        if (analysisInterval) clearInterval(analysisInterval);
    }

    // Kh·ªüi ƒë·ªông
    window.onload = async function() {
        await updatePriceRealtime();
        await analyzeMarket();
        startAutoRefresh();
    };

    window.onbeforeunload = function() {
        stopAutoRefresh();
    };
</script>
```

</body>
</html>
