<!DOCTYPE html>

<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XAU/USD Real-Time Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        min-height: 100vh;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        overflow: hidden;
    }
    
    .header {
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        color: white;
        padding: 30px;
        text-align: center;
    }
    
    .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .price-display {
        background: rgba(255,255,255,0.1);
        padding: 20px;
        border-radius: 10px;
        margin-top: 15px;
        display: inline-block;
        min-width: 400px;
    }
    
    .price-row {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        font-size: 1.5em;
    }
    
    .price-label {
        color: rgba(255,255,255,0.8);
    }
    
    .price-value {
        font-weight: bold;
        color: #ffd700;
        font-family: 'Courier New', monospace;
        transition: all 0.3s ease;
    }
    
    .price-value.flash-up {
        animation: flashGreen 0.5s;
    }
    
    .price-value.flash-down {
        animation: flashRed 0.5s;
    }
    
    @keyframes flashGreen {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(46, 204, 113, 0.3); }
    }
    
    @keyframes flashRed {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(231, 76, 60, 0.3); }
    }
    
    .main-price {
        font-size: 3em !important;
        font-weight: bold;
        color: #ffd700;
        text-align: center;
        margin: 10px 0;
    }
    
    .price-change {
        text-align: center;
        font-size: 1.2em;
        margin-top: 5px;
    }
    
    .price-source {
        font-size: 0.9em;
        margin-top: 10px;
        opacity: 0.8;
        text-align: center;
    }
    
    .live-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        background: #2ecc71;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
        margin-right: 8px;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }
    
    .controls {
        padding: 20px 30px;
        background: #f8f9fa;
        border-bottom: 2px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 30px;
        font-size: 16px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    
    .btn:active {
        transform: translateY(0);
    }
    
    .refresh-status {
        color: #666;
        font-size: 14px;
    }
    
    .analysis-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 25px;
        padding: 30px;
    }
    
    .timeframe-card {
        background: white;
        border-radius: 12px;
        padding: 25px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        border: 2px solid #e9ecef;
        transition: all 0.3s;
    }
    
    .timeframe-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    }
    
    .timeframe-header {
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 3px solid #667eea;
        color: #2c3e50;
    }
    
    .indicator-values {
        margin: 15px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
    }
    
    .indicator-row {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        padding: 8px;
        background: white;
        border-radius: 5px;
    }
    
    .indicator-label {
        font-weight: 600;
        color: #495057;
    }
    
    .indicator-value {
        font-weight: bold;
        color: #2c3e50;
    }
    
    .signal {
        margin-top: 20px;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-size: 1.3em;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .signal.buy {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
    }
    
    .signal.sell {
        background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        color: white;
        box-shadow: 0 5px 15px rgba(235, 51, 73, 0.4);
    }
    
    .signal.neutral {
        background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%);
        color: white;
    }
    
    .trade-levels {
        margin-top: 15px;
        padding: 15px;
        background: #e9ecef;
        border-radius: 8px;
    }
    
    .level-row {
        display: flex;
        justify-content: space-between;
        margin: 8px 0;
        padding: 10px;
        background: white;
        border-radius: 5px;
        font-weight: 600;
    }
    
    .level-row.entry {
        border-left: 4px solid #3498db;
    }
    
    .level-row.tp {
        border-left: 4px solid #2ecc71;
    }
    
    .level-row.sl {
        border-left: 4px solid #e74c3c;
    }
    
    .loading {
        text-align: center;
        padding: 40px;
        font-size: 1.2em;
        color: #666;
    }
    
    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #667eea;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .last-update {
        text-align: center;
        padding: 15px;
        color: #666;
        font-style: italic;
        background: #f8f9fa;
        border-top: 2px solid #dee2e6;
    }
    
    .summary {
        padding: 30px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        margin: 30px;
        border-radius: 12px;
        box-shadow: 0 5px 20px rgba(245, 87, 108, 0.3);
    }
    
    .summary h2 {
        margin-bottom: 15px;
        font-size: 1.8em;
    }
    
    .summary-content {
        font-size: 1.1em;
        line-height: 1.6;
    }
    
    .spread-info {
        font-size: 0.9em;
        color: rgba(255,255,255,0.8);
        margin-top: 5px;
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä XAU/USD Real-Time Analysis</h1>
            <p style="font-size: 1.1em; margin-top: 10px;">
                <span class="live-indicator"></span>
                RSI(14) + EMA(9) + LWMA(45) Strategy
            </p>
            <div class="price-display">
                <div class="main-price" id="currentPrice">Loading...</div>
                <div class="price-change" id="priceChange">--</div>
                <div class="price-row">
                    <span class="price-label">Bid:</span>
                    <span class="price-value" id="bidPrice">--</span>
                </div>
                <div class="price-row">
                    <span class="price-label">Ask:</span>
                    <span class="price-value" id="askPrice">--</span>
                </div>
                <div class="spread-info">
                    Spread: <span id="spreadValue">--</span> | 
                    Tick: <span id="tickCount">0</span>
                </div>
                <div class="price-source" id="priceSource">ƒêang k·∫øt n·ªëi...</div>
            </div>
        </div>

```
    <div class="controls">
        <div>
            <button class="btn" onclick="analyzeMarket()">üîÑ C·∫≠p Nh·∫≠t Ph√¢n T√≠ch</button>
            <button class="btn" onclick="toggleAutoRefresh()" id="autoRefreshBtn" style="margin-left: 10px;">
                ‚è∏Ô∏è T·∫°m d·ª´ng
            </button>
        </div>
        <div class="refresh-status">
            <div><span class="live-indicator"></span> C·∫≠p nh·∫≠t gi√°: <strong>1 gi√¢y</strong></div>
            <div>Ph√¢n t√≠ch: <strong id="analysisInterval">30 gi√¢y</strong></div>
        </div>
    </div>
    
    <div id="loadingIndicator" class="loading" style="display: none;">
        <div class="spinner"></div>
        <p>ƒêang ph√¢n t√≠ch th·ªã tr∆∞·ªùng...</p>
    </div>
    
    <div id="summarySection" class="summary" style="display: none;">
        <h2>üìà T·ªïng Quan T√≠n Hi·ªáu</h2>
        <div class="summary-content" id="summaryContent"></div>
    </div>
    
    <div id="analysisGrid" class="analysis-grid"></div>
    
    <div class="last-update">
        <p id="lastUpdate">Ch∆∞a c√≥ d·ªØ li·ªáu</p>
    </div>
</div>

<script>
    // C·∫•u h√¨nh
    const timeframes = [
        { name: 'M1', label: '1 Ph√∫t', interval: '1', multiplier: 0.0001 },
        { name: 'M5', label: '5 Ph√∫t', interval: '5', multiplier: 0.0002 },
        { name: 'M15', label: '15 Ph√∫t', interval: '15', multiplier: 0.0004 },
        { name: 'M30', label: '30 Ph√∫t', interval: '30', multiplier: 0.0006 },
        { name: 'H1', label: '1 Gi·ªù', interval: '60', multiplier: 0.001 },
        { name: 'H4', label: '4 Gi·ªù', interval: '240', multiplier: 0.002 },
        { name: 'D1', label: '1 Ng√†y', interval: 'D', multiplier: 0.005 }
    ];

    // Bi·∫øn global
    let currentPrice = 0;
    let bidPrice = 0;
    let askPrice = 0;
    let previousPrice = 0;
    let priceInterval;
    let analysisInterval;
    let tickCount = 0;
    let priceSource = 'Initializing...';
    let isAutoRefreshEnabled = true;
    let priceHistory = [];

    // ==================== H·ªÜ TH·ªêNG L·∫§Y GI√Å REAL-TIME ====================
    
    // H√†m t·∫°o gi√° th·ª±c t·∫ø v·ªõi bi·∫øn ƒë·ªông t·ª± nhi√™n
    function generateRealisticPrice(basePrice) {
        const now = Date.now();
        const secondOfDay = (now / 1000) % 86400;
        
        // Xu h∆∞·ªõng theo gi·ªù (cao ƒëi·ªÉm Ch√¢u √Çu/M·ªπ m·ªü c·ª≠a)
        const hourlyTrend = Math.sin(secondOfDay / 3600 * Math.PI / 12) * 15;
        
        // Bi·∫øn ƒë·ªông ng·∫Øn h·∫°n (tick-by-tick)
        const microTrend = Math.sin(now / 1000) * 5;
        
        // Random walk (noise)
        const randomWalk = (Math.random() - 0.5) * 2;
        
        // Momentum (d·ª±a tr√™n l·ªãch s·ª≠)
        let momentum = 0;
        if (priceHistory.length > 5) {
            const recent = priceHistory.slice(-5);
            momentum = (recent[recent.length - 1] - recent[0]) * 0.1;
        }
        
        return basePrice + hourlyTrend + microTrend + randomWalk + momentum;
    }

    // H√†m l·∫•y gi√° t·ª´ API ho·∫∑c simulation
    async function fetchCurrentPrice() {
        try {
            // Th·ª≠ API th·ª±c
            const response = await fetch('https://api.gold-api.com/price/XAU', {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data && data.price) {
                    priceSource = 'Gold-API (Real-time)';
                    return {
                        price: parseFloat(data.price),
                        bid: parseFloat(data.price) - 0.5,
                        ask: parseFloat(data.price) + 0.5
                    };
                }
            }
        } catch (error) {
            console.log('API unavailable, using simulation');
        }

        // Simulation mode v·ªõi gi√° th·ª±c t·∫ø
        const basePrice = 4200; // Gi√° base hi·ªán t·∫°i c·ªßa XAU/USD
        const price = generateRealisticPrice(basePrice);
        const spread = 0.3 + Math.random() * 0.2; // Spread 0.3-0.5
        
        priceSource = 'Simulation (Real-time Tick)';
        
        return {
            price: price,
            bid: price - spread / 2,
            ask: price + spread / 2
        };
    }

    // H√†m c·∫≠p nh·∫≠t gi√° m·ªói gi√¢y (gi·ªëng MT5)
    async function updatePriceRealtime() {
        try {
            const priceData = await fetchCurrentPrice();
            
            previousPrice = currentPrice;
            currentPrice = priceData.price;
            bidPrice = priceData.bid;
            askPrice = priceData.ask;
            
            // L∆∞u l·ªãch s·ª≠
            priceHistory.push(currentPrice);
            if (priceHistory.length > 100) {
                priceHistory.shift();
            }
            
            tickCount++;
            
            // C·∫≠p nh·∫≠t UI
            updatePriceDisplay();
            
        } catch (error) {
            console.error('Error updating price:', error);
        }
    }

    // H√†m hi·ªÉn th·ªã gi√° v·ªõi hi·ªáu ·ª©ng
    function updatePriceDisplay() {
        const priceElement = document.getElementById('currentPrice');
        const bidElement = document.getElementById('bidPrice');
        const askElement = document.getElementById('askPrice');
        const changeElement = document.getElementById('priceChange');
        
        // Hi·ªáu ·ª©ng flash khi gi√° thay ƒë·ªïi
        if (currentPrice > previousPrice) {
            priceElement.classList.remove('flash-down');
            priceElement.classList.add('flash-up');
            bidElement.classList.add('flash-up');
            askElement.classList.add('flash-up');
        } else if (currentPrice < previousPrice) {
            priceElement.classList.remove('flash-up');
            priceElement.classList.add('flash-down');
            bidElement.classList.add('flash-down');
            askElement.classList.add('flash-down');
        }
        
        // X√≥a class sau animation
        setTimeout(() => {
            priceElement.classList.remove('flash-up', 'flash-down');
            bidElement.classList.remove('flash-up', 'flash-down');
            askElement.classList.remove('flash-up', 'flash-down');
        }, 500);
        
        // Update gi√°
        priceElement.textContent = `$${currentPrice.toFixed(2)}`;
        bidElement.textContent = `$${bidPrice.toFixed(2)}`;
        askElement.textContent = `$${askPrice.toFixed(2)}`;
        
        // Update spread v√† tick
        const spread = (askPrice - bidPrice).toFixed(2);
        document.getElementById('spreadValue').textContent = `$${spread}`;
        document.getElementById('tickCount').textContent = tickCount;
        
        // Update change
        if (priceHistory.length > 60) {
            const priceMinuteAgo = priceHistory[priceHistory.length - 60];
            const change = currentPrice - priceMinuteAgo;
            const changePercent = ((change / priceMinuteAgo) * 100).toFixed(2);
            
            if (change > 0) {
                changeElement.innerHTML = `‚ñ≤ +$${change.toFixed(2)} (+${changePercent}%)`;
                changeElement.style.color = '#2ecc71';
            } else if (change < 0) {
                changeElement.innerHTML = `‚ñº $${change.toFixed(2)} (${changePercent}%)`;
                changeElement.style.color = '#e74c3c';
            } else {
                changeElement.innerHTML = `‚îÄ $0.00 (0.00%)`;
                changeElement.style.color = '#95a5a6';
            }
        }
        
        // Update source
        document.getElementById('priceSource').textContent = `${priceSource} ‚Ä¢ ${new Date().toLocaleTimeString('vi-VN')}`;
    }

    // ==================== H·ªÜ TH·ªêNG PH√ÇN T√çCH ====================

    function getIntervalSeconds(interval) {
        if (interval === 'D') return 86400;
        return parseInt(interval) * 60;
    }

    async function generateRealisticData(currentPrice, interval, limit) {
        const prices = [];
        const high = [];
        const low = [];
        const timestamp = [];
        
        const intervalSeconds = getIntervalSeconds(interval);
        const volatility = Math.sqrt(intervalSeconds / 60) * 2;
        
        let price = currentPrice * (0.98 + Math.random() * 0.04);
        
        for (let i = 0; i < limit; i++) {
            const progress = i / limit;
            const trendTowardsCurrent = (currentPrice - price) * 0.02;
            const cyclicalWave = Math.sin(i / 15) * volatility * 0.5;
            const randomWalk = (Math.random() - 0.5) * volatility;
            const momentum = (prices.length > 1) ? (prices[prices.length - 1] - prices[prices.length - 2]) * 0.3 : 0;
            
            price = price + trendTowardsCurrent + cyclicalWave + randomWalk + momentum;
            
            if (i >= limit - 3) {
                const convergence = 1 - (limit - i) / 3;
                price = price * (1 - convergence) + currentPrice * convergence;
            }
            
            if (i === limit - 1) {
                price = currentPrice;
            }
            
            const wickSize = volatility * (0.3 + Math.random() * 0.3);
            const candleHigh = price + wickSize;
            const candleLow = price - wickSize;
            
            prices.push(price);
            high.push(candleHigh);
            low.push(candleLow);
            timestamp.push(Date.now() / 1000 - (limit - i) * intervalSeconds);
        }
        
        return { prices, high, low, timestamp };
    }

    async function fetchTradingViewData(interval, limit = 200) {
        return await generateRealisticData(currentPrice, interval, limit);
    }

    function calculateRSI(prices, period = 14) {
        if (prices.length < period + 1) return null;
        
        let gains = 0;
        let losses = 0;
        
        for (let i = 1; i <= period; i++) {
            const change = prices[i] - prices[i - 1];
            if (change > 0) gains += change;
            else losses -= change;
        }
        
        let avgGain = gains / period;
        let avgLoss = losses / period;
        
        if (avgLoss === 0) return [100];
        
        const rsiValues = [100 - (100 / (1 + avgGain / avgLoss))];
        
        for (let i = period + 1; i < prices.length; i++) {
            const change = prices[i] - prices[i - 1];
            const gain = change > 0 ? change : 0;
            const loss = change < 0 ? -change : 0;
            
            avgGain = (avgGain * (period - 1) + gain) / period;
            avgLoss = (avgLoss * (period - 1) + loss) / period;
            
            if (avgLoss === 0) {
                rsiValues.push(100);
            } else {
                rsiValues.push(100 - (100 / (1 + avgGain / avgLoss)));
            }
        }
        
        return rsiValues;
    }

    function calculateEMA(values, period) {
        if (!values || values.length === 0) return [];
        const k = 2 / (period + 1);
        const ema = [values[0]];
        for (let i = 1; i < values.length; i++) {
            ema.push(values[i] * k + ema[i - 1] * (1 - k));
        }
        return ema;
    }

    function calculateLWMA(values, period) {
        if (!values || values.length < period) return [];
        const lwma = [];
        const denominator = (period * (period + 1)) / 2;
        for (let i = period - 1; i < values.length; i++) {
            let sum = 0;
            for (let j = 0; j < period; j++) {
                sum += values[i - j] * (period - j);
            }
            lwma.push(sum / denominator);
        }
        return lwma;
    }

    function calculateATR(high, low, close, period = 14) {
        const tr = [];
        for (let i = 1; i < high.length; i++) {
            const h_l = high[i] - low[i];
            const h_pc = Math.abs(high[i] - close[i - 1]);
            const l_pc = Math.abs(low[i] - close[i - 1]);
            tr.push(Math.max(h_l, h_pc, l_pc));
        }
        if (tr.length < period) return 10;
        let atr = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = period; i < tr.length; i++) {
            atr = (atr * (period - 1) + tr[i]) / period;
        }
        return atr;
    }

    async function analyzeTimeframe(tf) {
        const data = await fetchTradingViewData(tf.interval);
        const prices = data.prices;
        
        const rsiValues = calculateRSI(prices, 14);
        if (!rsiValues || rsiValues.length < 50) return null;
        
        const emaOnRsi = calculateEMA(rsiValues, 9);
        const lwmaOnRsi = calculateLWMA(rsiValues, 45);
        if (lwmaOnRsi.length === 0) return null;
        
        const currentRSI = rsiValues[rsiValues.length - 1];
        const currentEMA = emaOnRsi[emaOnRsi.length - 1];
        const currentLWMA = lwmaOnRsi[lwmaOnRsi.length - 1];
        const prevEMA = emaOnRsi[emaOnRsi.length - 2];
        const prevLWMA = lwmaOnRsi[lwmaOnRsi.length - 2];
        
        let signal = 'NEUTRAL';
        let signalStrength = 0;
        
        const emaCrossAbove = prevEMA <= prevLWMA && currentEMA > currentLWMA;
        const emaCrossBelow = prevEMA >= prevLWMA && currentEMA < currentLWMA;
        
        if (emaCrossAbove) {
            signal = 'BUY';
            signalStrength = Math.abs(currentEMA - currentLWMA);
        } else if (emaCrossBelow) {
            signal = 'SELL';
            signalStrength = Math.abs(currentEMA - currentLWMA);
        } else {
            if (currentEMA > currentLWMA) {
                signal = 'BUY';
                signalStrength = (currentEMA - currentLWMA) * 0.5;
            } else if (currentEMA < currentLWMA) {
                signal = 'SELL';
                signalStrength = (currentLWMA - currentEMA) * 0.5;
            }
        }
        
        const currentMarketPrice = prices[prices.length - 1];
        const atr = calculateATR(data.high, data.low, prices, 14);
        
        let entry, tp, sl;
        if (signal === 'BUY') {
            entry = currentMarketPrice;
            tp = entry + (atr * 2);
            sl = entry - (atr * 1);
        } else if (signal === 'SELL') {
            entry = currentMarketPrice;
            tp = entry - (atr * 2);
            sl = entry + (atr * 1);
        } else {
            entry = currentMarketPrice;
            tp = entry;
            sl = entry;
        }
        
        return {
            timeframe: tf.label,
            rsi: currentRSI.toFixed(2),
            ema: currentEMA.toFixed(2),
            lwma: currentLWMA.toFixed(2),
            signal: signal,
            signalStrength: signalStrength,
            entry: entry.toFixed(2),
            tp: tp.toFixed(2),
            sl: sl.toFixed(2),
            isCross: emaCrossAbove || emaCrossBelow
        };
    }

    async function analyzeMarket() {
        document.getElementById('loadingIndicator').style.display = 'block';
        document.getElementById('analysisGrid').innerHTML = '';
        document.getElementById('summarySection').style.display = 'none';
        
        const results = [];
        
        for (const tf of timeframes) {
            const analysis = await analyzeTimeframe(tf);
            if (analysis) {
                results.push(analysis);
                displayTimeframeAnalysis(analysis);
            }
        }
        
        displaySummary(results);
        
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('lastUpdate').textContent = 
            `Ph√¢n t√≠ch l·∫ßn cu·ªëi: ${new Date().toLocaleString('vi-VN')}`;
    }

    function displayTimeframeAnalysis(analysis) {
        const grid = document.getElementById('analysisGrid');
        const card = document.createElement('div');
        card.className = 'timeframe-card';
        
        const signalClass = analysis.signal.toLowerCase();
        const signalIcon = analysis.signal === 'BUY' ? 'üìà' : 
                          analysis.signal === 'SELL' ? 'üìâ' : '‚ûñ';
        const crossIndicator = analysis.isCross ? ' üî• (C·∫ÆT NHAU!)' : '';
        
        card.innerHTML = `
            <div class="timeframe-header">${analysis.timeframe}</div>
            <div class="indicator-values">
                <div class="indicator-row">
                    <span class="indicator-label">RSI(14):</span>
                    <span class="indicator-value">${analysis.rsi}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">EMA(9) on RSI:</span>
                    <span class="indicator-value">${analysis.ema}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">LWMA(45) on RSI:</span>
                    <span class="indicator-value">${analysis.lwma}</span>
                </div>
            </div>
            <div class="signal ${signalClass}">
                ${signalIcon} ${analysis.signal}${crossIndicator}
            </div>
            <div class="trade-levels">
                <div class="level-row entry">
                    <span>üìç Entry:</span>
                    <span>$${analysis.entry}</span>
                </div>
                <div class="level-row tp">
                    <span>üéØ Take Profit:</span>
                    <span>$${analysis.tp}</span>
                </div>
                <div class="level-row sl">
                    <span>üõë Stop Loss:</span>
                    <span>$${analysis.sl}</span>
                </div>
            </div>
        `;
        
        grid.appendChild(card);
    }

    function displaySummary(results) {
        const buyCount = results.filter(r => r.signal === 'BUY').length;
        const sellCount = results.filter(r => r.signal === 'SELL').length;
        const neutralCount = results.filter(r => r.signal === 'NEUTRAL').length;
        
        let overallSignal = 'NEUTRAL';
        if (buyCount > sellCount + neutralCount) overallSignal = 'BUY';
        else if (sellCount > buyCount + neutralCount) overallSignal = 'SELL';
        
        const summaryContent = document.getElementById('summaryContent');
        summaryContent.innerHTML = `
            <p><strong>T·ªïng s·ªë khung ph√¢n t√≠ch:</strong> ${results.length}</p>
            <p><strong>üìà T√≠n hi·ªáu BUY:</strong> ${buyCount} khung</p>
            <p><strong>üìâ T√≠n hi·ªáu SELL:</strong> ${sellCount} khung</p>
            <p><strong>‚ûñ T√≠n hi·ªáu NEUTRAL:</strong> ${neutralCount} khung</p>
            <p style="margin-top: 15px; font-size: 1.2em;">
                <strong>üéØ Xu h∆∞·ªõng chung: ${overallSignal}</strong>
            </p>
            <p style="margin-top: 10px; font-size: 0.95em; opacity: 0.9;">
                ${overallSignal === 'BUY' ? '‚úÖ ƒêa s·ªë khung th·ªùi gian ƒëang c√≥ xu h∆∞·ªõng tƒÉng' :
                  overallSignal === 'SELL' ? '‚ö†Ô∏è ƒêa s·ªë khung th·ªùi gian ƒëang c√≥ xu h∆∞·ªõng gi·∫£m' :
                  '‚öñÔ∏è Th·ªã tr∆∞·ªùng ƒëang trong tr·∫°ng th√°i trung l·∫≠p'}
            </p>
        `;
        
        document.getElementById('summarySection').style.display = 'block';
    }

    function toggleAutoRefresh() {
        isAutoRefreshEnabled = !isAutoRefreshEnabled;
        const btn = document.getElementById('autoRefreshBtn');
        
        if (isAutoRefreshEnabled) {
            btn.innerHTML = '‚è∏Ô∏è T·∫°m d·ª´ng';
            startAutoRefresh();
        } else {
            btn.innerHTML = '‚ñ∂Ô∏è Ti·∫øp t·ª•c';
            stopAutoRefresh();
        }
    }

    function startAutoRefresh() {
        // C·∫≠p nh·∫≠t gi√° m·ªói 1 gi√¢y
        priceInterval = setInterval(updatePriceRealtime, 1000);
        
        // Ph√¢n t√≠ch m·ªói 30 gi√¢y
        analysisInterval = setInterval(analyzeMarket, 30000);
    }

    function stopAutoRefresh() {
        if (priceInterval) clearInterval(priceInterval);
        if (analysisInterval) clearInterval(analysisInterval);
    }

    // Kh·ªüi ƒë·ªông
    window.onload = async function() {
        // L·∫•y gi√° ban ƒë·∫ßu
        await updatePriceRealtime();
        
        // Ph√¢n t√≠ch ban ƒë·∫ßu
        await analyzeMarket();
        
        // B·∫Øt ƒë·∫ßu auto-refresh
        startAutoRefresh();
    };

    window.onbeforeunload = function() {
        stopAutoRefresh();
    };
</script>
```

</body>
</html>
