<!DOCTYPE html>

<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XAU/USD Real-Time Analysis - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        min-height: 100vh;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        overflow: hidden;
    }
    
    .header {
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        color: white;
        padding: 30px;
        text-align: center;
    }
    
    .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .price-display {
        background: rgba(255,255,255,0.1);
        padding: 20px;
        border-radius: 10px;
        margin-top: 15px;
        display: inline-block;
        min-width: 400px;
    }
    
    .price-row {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        font-size: 1.5em;
    }
    
    .price-label {
        color: rgba(255,255,255,0.8);
    }
    
    .price-value {
        font-weight: bold;
        color: #ffd700;
        font-family: 'Courier New', monospace;
        transition: all 0.3s ease;
    }
    
    .price-value.flash-up {
        animation: flashGreen 0.5s;
    }
    
    .price-value.flash-down {
        animation: flashRed 0.5s;
    }
    
    @keyframes flashGreen {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(46, 204, 113, 0.3); }
    }
    
    @keyframes flashRed {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(231, 76, 60, 0.3); }
    }
    
    .main-price {
        font-size: 3em !important;
        font-weight: bold;
        color: #ffd700;
        text-align: center;
        margin: 10px 0;
    }
    
    .price-change {
        text-align: center;
        font-size: 1.2em;
        margin-top: 5px;
    }
    
    .price-source {
        font-size: 0.9em;
        margin-top: 10px;
        opacity: 0.8;
        text-align: center;
    }
    
    .live-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        background: #2ecc71;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
        margin-right: 8px;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }
    
    .controls {
        padding: 20px 30px;
        background: #f8f9fa;
        border-bottom: 2px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 30px;
        font-size: 16px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    
    .btn:active {
        transform: translateY(0);
    }
    
    .refresh-status {
        color: #666;
        font-size: 14px;
    }
    
    .analysis-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 25px;
        padding: 30px;
    }
    
    .timeframe-card {
        background: white;
        border-radius: 12px;
        padding: 25px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        border: 2px solid #e9ecef;
        transition: all 0.3s;
    }
    
    .timeframe-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    }
    
    .timeframe-header {
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 3px solid #667eea;
        color: #2c3e50;
    }
    
    .indicator-values {
        margin: 15px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
    }
    
    .indicator-row {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        padding: 8px;
        background: white;
        border-radius: 5px;
    }
    
    .indicator-label {
        font-weight: 600;
        color: #495057;
    }
    
    .indicator-value {
        font-weight: bold;
        color: #2c3e50;
    }
    
    .signal {
        margin-top: 20px;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-size: 1.3em;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .signal.buy {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
    }
    
    .signal.sell {
        background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        color: white;
        box-shadow: 0 5px 15px rgba(235, 51, 73, 0.4);
    }
    
    .signal.neutral {
        background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%);
        color: white;
    }
    
    .trade-levels {
        margin-top: 15px;
        padding: 15px;
        background: #e9ecef;
        border-radius: 8px;
    }
    
    .level-row {
        display: flex;
        justify-content: space-between;
        margin: 8px 0;
        padding: 10px;
        background: white;
        border-radius: 5px;
        font-weight: 600;
    }
    
    .level-row.entry {
        border-left: 4px solid #3498db;
    }
    
    .level-row.tp {
        border-left: 4px solid #2ecc71;
    }
    
    .level-row.sl {
        border-left: 4px solid #e74c3c;
    }
    
    .loading {
        text-align: center;
        padding: 40px;
        font-size: 1.2em;
        color: #666;
    }
    
    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #667eea;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .last-update {
        text-align: center;
        padding: 15px;
        color: #666;
        font-style: italic;
        background: #f8f9fa;
        border-top: 2px solid #dee2e6;
    }
    
    .summary {
        padding: 30px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        margin: 30px;
        border-radius: 12px;
        box-shadow: 0 5px 20px rgba(245, 87, 108, 0.3);
    }
    
    .summary h2 {
        margin-bottom: 15px;
        font-size: 1.8em;
    }
    
    .summary-content {
        font-size: 1.1em;
        line-height: 1.6;
    }
    
    .spread-info {
        font-size: 0.9em;
        color: rgba(255,255,255,0.8);
        margin-top: 5px;
    }

    .signal-strength-bar {
        margin-top: 15px;
        padding: 15px;
        background: white;
        border-radius: 8px;
    }

    .strength-label {
        font-size: 0.9em;
        color: #495057;
        margin-bottom: 8px;
        font-weight: 600;
    }

    .strength-bar {
        height: 25px;
        background: #e9ecef;
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }

    .strength-fill {
        height: 100%;
        transition: width 0.5s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 0.85em;
    }

    .strength-fill.strong {
        background: linear-gradient(90deg, #11998e 0%, #38ef7d 100%);
    }

    .strength-fill.medium {
        background: linear-gradient(90deg, #f39c12 0%, #f1c40f 100%);
    }

    .strength-fill.weak {
        background: linear-gradient(90deg, #95a5a6 0%, #bdc3c7 100%);
    }

    .confluence-score {
        margin-top: 15px;
        padding: 15px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 8px;
        color: white;
        text-align: center;
    }

    .confluence-score .score-value {
        font-size: 2em;
        font-weight: bold;
        margin: 10px 0;
    }

    .confluence-details {
        font-size: 0.85em;
        margin-top: 10px;
        opacity: 0.9;
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä XAU/USD Real-Time Analysis - Enhanced</h1>
            <p style="font-size: 1.1em; margin-top: 10px;">
                <span class="live-indicator"></span>
                Multi-Indicator Confluence System
            </p>
            <div class="price-display">
                <div class="main-price" id="currentPrice">Loading...</div>
                <div class="price-change" id="priceChange">--</div>
                <div class="price-row">
                    <span class="price-label">Bid:</span>
                    <span class="price-value" id="bidPrice">--</span>
                </div>
                <div class="price-row">
                    <span class="price-label">Ask:</span>
                    <span class="price-value" id="askPrice">--</span>
                </div>
                <div class="spread-info">
                    Spread: <span id="spreadValue">--</span> | 
                    Tick: <span id="tickCount">0</span>
                </div>
                <div class="price-source" id="priceSource">ƒêang k·∫øt n·ªëi...</div>
            </div>
        </div>

```
    <div class="controls">
        <div>
            <button class="btn" onclick="analyzeMarket()">üîÑ C·∫≠p Nh·∫≠t Ph√¢n T√≠ch</button>
            <button class="btn" onclick="toggleAutoRefresh()" id="autoRefreshBtn" style="margin-left: 10px;">
                ‚è∏Ô∏è T·∫°m d·ª´ng
            </button>
        </div>
        <div class="refresh-status">
            <div><span class="live-indicator"></span> C·∫≠p nh·∫≠t gi√°: <strong>1 gi√¢y</strong></div>
            <div>Ph√¢n t√≠ch: <strong id="analysisInterval">30 gi√¢y</strong></div>
        </div>
    </div>
    
    <div id="loadingIndicator" class="loading" style="display: none;">
        <div class="spinner"></div>
        <p>ƒêang ph√¢n t√≠ch th·ªã tr∆∞·ªùng...</p>
    </div>
    
    <div id="summarySection" class="summary" style="display: none;">
        <h2>üìà T·ªïng Quan T√≠n Hi·ªáu</h2>
        <div class="summary-content" id="summaryContent"></div>
    </div>
    
    <div id="analysisGrid" class="analysis-grid"></div>
    
    <div class="last-update">
        <p id="lastUpdate">Ch∆∞a c√≥ d·ªØ li·ªáu</p>
    </div>
</div>

<script>
    // C·∫•u h√¨nh
    const timeframes = [
        { name: 'M1', label: '1 Ph√∫t', interval: '1', multiplier: 0.0001 },
        { name: 'M5', label: '5 Ph√∫t', interval: '5', multiplier: 0.0002 },
        { name: 'M15', label: '15 Ph√∫t', interval: '15', multiplier: 0.0004 },
        { name: 'M30', label: '30 Ph√∫t', interval: '30', multiplier: 0.0006 },
        { name: 'H1', label: '1 Gi·ªù', interval: '60', multiplier: 0.001 },
        { name: 'H4', label: '4 Gi·ªù', interval: '240', multiplier: 0.002 },
        { name: 'D1', label: '1 Ng√†y', interval: 'D', multiplier: 0.005 }
    ];

    // Bi·∫øn global
    let currentPrice = 0;
    let bidPrice = 0;
    let askPrice = 0;
    let previousPrice = 0;
    let priceInterval;
    let analysisInterval;
    let tickCount = 0;
    let priceSource = 'Initializing...';
    let isAutoRefreshEnabled = true;
    let priceHistory = [];

    // ==================== H·ªÜ TH·ªêNG L·∫§Y GI√Å REAL-TIME ====================
    
    function generateRealisticPrice(basePrice) {
        const now = Date.now();
        const secondOfDay = (now / 1000) % 86400;
        const hourlyTrend = Math.sin(secondOfDay / 3600 * Math.PI / 12) * 15;
        const microTrend = Math.sin(now / 1000) * 5;
        const randomWalk = (Math.random() - 0.5) * 2;
        let momentum = 0;
        if (priceHistory.length > 5) {
            const recent = priceHistory.slice(-5);
            momentum = (recent[recent.length - 1] - recent[0]) * 0.1;
        }
        return basePrice + hourlyTrend + microTrend + randomWalk + momentum;
    }

    async function fetchCurrentPrice() {
        try {
            const response = await fetch('https://api.gold-api.com/price/XAU', {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data && data.price) {
                    priceSource = 'Gold-API (Real-time)';
                    return {
                        price: parseFloat(data.price),
                        bid: parseFloat(data.price) - 0.5,
                        ask: parseFloat(data.price) + 0.5
                    };
                }
            }
        } catch (error) {
            console.log('API unavailable, using simulation');
        }

        const basePrice = 4200;
        const price = generateRealisticPrice(basePrice);
        const spread = 0.3 + Math.random() * 0.2;
        priceSource = 'Simulation (Real-time Tick)';
        
        return {
            price: price,
            bid: price - spread / 2,
            ask: price + spread / 2
        };
    }

    async function updatePriceRealtime() {
        try {
            const priceData = await fetchCurrentPrice();
            previousPrice = currentPrice;
            currentPrice = priceData.price;
            bidPrice = priceData.bid;
            askPrice = priceData.ask;
            priceHistory.push(currentPrice);
            if (priceHistory.length > 100) {
                priceHistory.shift();
            }
            tickCount++;
            updatePriceDisplay();
        } catch (error) {
            console.error('Error updating price:', error);
        }
    }

    function updatePriceDisplay() {
        const priceElement = document.getElementById('currentPrice');
        const bidElement = document.getElementById('bidPrice');
        const askElement = document.getElementById('askPrice');
        const changeElement = document.getElementById('priceChange');
        
        if (currentPrice > previousPrice) {
            priceElement.classList.remove('flash-down');
            priceElement.classList.add('flash-up');
            bidElement.classList.add('flash-up');
            askElement.classList.add('flash-up');
        } else if (currentPrice < previousPrice) {
            priceElement.classList.remove('flash-up');
            priceElement.classList.add('flash-down');
            bidElement.classList.add('flash-down');
            askElement.classList.add('flash-down');
        }
        
        setTimeout(() => {
            priceElement.classList.remove('flash-up', 'flash-down');
            bidElement.classList.remove('flash-up', 'flash-down');
            askElement.classList.remove('flash-up', 'flash-down');
        }, 500);
        
        priceElement.textContent = `$${currentPrice.toFixed(2)}`;
        bidElement.textContent = `$${bidPrice.toFixed(2)}`;
        askElement.textContent = `$${askPrice.toFixed(2)}`;
        
        const spread = (askPrice - bidPrice).toFixed(2);
        document.getElementById('spreadValue').textContent = `$${spread}`;
        document.getElementById('tickCount').textContent = tickCount;
        
        if (priceHistory.length > 60) {
            const priceMinuteAgo = priceHistory[priceHistory.length - 60];
            const change = currentPrice - priceMinuteAgo;
            const changePercent = ((change / priceMinuteAgo) * 100).toFixed(2);
            
            if (change > 0) {
                changeElement.innerHTML = `‚ñ≤ +$${change.toFixed(2)} (+${changePercent}%)`;
                changeElement.style.color = '#2ecc71';
            } else if (change < 0) {
                changeElement.innerHTML = `‚ñº $${change.toFixed(2)} (${changePercent}%)`;
                changeElement.style.color = '#e74c3c';
            } else {
                changeElement.innerHTML = `‚îÄ $0.00 (0.00%)`;
                changeElement.style.color = '#95a5a6';
            }
        }
        
        document.getElementById('priceSource').textContent = `${priceSource} ‚Ä¢ ${new Date().toLocaleTimeString('vi-VN')}`;
    }

    // ==================== ENHANCED TECHNICAL INDICATORS ====================

    function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
        const fastEMA = calculateEMA(prices, fastPeriod);
        const slowEMA = calculateEMA(prices, slowPeriod);
        
        const macdLine = [];
        for (let i = 0; i < fastEMA.length; i++) {
            macdLine.push(fastEMA[i] - slowEMA[i]);
        }
        
        const signalLine = calculateEMA(macdLine, signalPeriod);
        const histogram = [];
        
        for (let i = 0; i < macdLine.length; i++) {
            histogram.push(macdLine[i] - signalLine[i]);
        }
        
        return { macdLine, signalLine, histogram };
    }

    function calculateBollingerBands(prices, period = 20, stdDev = 2) {
        const sma = calculateSMA(prices, period);
        const bands = { upper: [], middle: [], lower: [] };
        
        for (let i = period - 1; i < prices.length; i++) {
            const slice = prices.slice(i - period + 1, i + 1);
            const mean = sma[i - period + 1];
            const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
            const std = Math.sqrt(variance);
            
            bands.middle.push(mean);
            bands.upper.push(mean + stdDev * std);
            bands.lower.push(mean - stdDev * std);
        }
        
        return bands;
    }

    function calculateSMA(values, period) {
        const sma = [];
        for (let i = period - 1; i < values.length; i++) {
            const sum = values.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
            sma.push(sum / period);
        }
        return sma;
    }

    function calculateStochastic(high, low, close, kPeriod = 14, dPeriod = 3) {
        const kValues = [];
        
        for (let i = kPeriod - 1; i < close.length; i++) {
            const highestHigh = Math.max(...high.slice(i - kPeriod + 1, i + 1));
            const lowestLow = Math.min(...low.slice(i - kPeriod + 1, i + 1));
            const k = ((close[i] - lowestLow) / (highestHigh - lowestLow)) * 100;
            kValues.push(k);
        }
        
        const dValues = calculateSMA(kValues, dPeriod);
        
        return { k: kValues, d: dValues };
    }

    function calculateADX(high, low, close, period = 14) {
        const tr = [];
        const plusDM = [];
        const minusDM = [];
        
        for (let i = 1; i < close.length; i++) {
            const h_l = high[i] - low[i];
            const h_pc = Math.abs(high[i] - close[i - 1]);
            const l_pc = Math.abs(low[i] - close[i - 1]);
            tr.push(Math.max(h_l, h_pc, l_pc));
            
            const highDiff = high[i] - high[i - 1];
            const lowDiff = low[i - 1] - low[i];
            
            plusDM.push(highDiff > lowDiff && highDiff > 0 ? highDiff : 0);
            minusDM.push(lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0);
        }
        
        const smoothedTR = calculateSMA(tr, period);
        const smoothedPlusDM = calculateSMA(plusDM, period);
        const smoothedMinusDM = calculateSMA(minusDM, period);
        
        const plusDI = [];
        const minusDI = [];
        const dx = [];
        
        for (let i = 0; i < smoothedTR.length; i++) {
            const pdi = (smoothedPlusDM[i] / smoothedTR[i]) * 100;
            const mdi = (smoothedMinusDM[i] / smoothedTR[i]) * 100;
            plusDI.push(pdi);
            minusDI.push(mdi);
            
            const sum = pdi + mdi;
            if (sum > 0) {
                dx.push((Math.abs(pdi - mdi) / sum) * 100);
            } else {
                dx.push(0);
            }
        }
        
        const adx = calculateSMA(dx, period);
        
        return { 
            adx: adx.length > 0 ? adx[adx.length - 1] : 0,
            plusDI: plusDI.length > 0 ? plusDI[plusDI.length - 1] : 0,
            minusDI: minusDI.length > 0 ? minusDI[minusDI.length - 1] : 0
        };
    }

    function calculateCCI(high, low, close, period = 20) {
        const tp = close.map((c, i) => (high[i] + low[i] + c) / 3);
        const sma = calculateSMA(tp, period);
        const cci = [];
        
        for (let i = period - 1; i < tp.length; i++) {
            const slice = tp.slice(i - period + 1, i + 1);
            const meanDev = slice.reduce((sum, val) => sum + Math.abs(val - sma[i - period + 1]), 0) / period;
            const cciVal = (tp[i] - sma[i - period + 1]) / (0.015 * meanDev);
            cci.push(cciVal);
        }
        
        return cci;
    }

    function detectVolumeProfile(prices, volume = null) {
        if (!volume) {
            volume = prices.map(() => 1 + Math.random());
        }
        
        const priceMin = Math.min(...prices);
        const priceMax = Math.max(...prices);
        const priceRange = priceMax - priceMin;
        const bucketSize = priceRange / 20;
        
        const volumeProfile = new Array(20).fill(0);
        
        for (let i = 0; i < prices.length; i++) {
            const bucketIndex = Math.min(Math.floor((prices[i] - priceMin) / bucketSize), 19);
            volumeProfile[bucketIndex] += volume[i];
        }
        
        const pocIndex = volumeProfile.indexOf(Math.max(...volumeProfile));
        const poc = priceMin + (pocIndex + 0.5) * bucketSize;
        
        return {
            poc: poc,
            highVolume: volumeProfile.filter(v => v > volumeProfile.reduce((a, b) => a + b) / 20)
        };
    }

    // ==================== CONFLUENCE SCORING SYSTEM ====================

    function calculateConfluenceScore(indicators, signal) {
        let score = 0;
        let maxScore = 0;
        const details = [];
        
        // RSI Score (0-15 points)
        maxScore += 15;
        if (signal === 'BUY') {
            if (indicators.rsi < 30) {
                score += 15;
                details.push('‚úì RSI Oversold');
            } else if (indicators.rsi < 40) {
                score += 10;
                details.push('‚úì RSI Bullish');
            } else if (indicators.rsi < 50) {
                score += 5;
                details.push('‚óã RSI Neutral+');
            }
        } else if (signal === 'SELL') {
            if (indicators.rsi > 70) {
                score += 15;
                details.push('‚úì RSI Overbought');
            } else if (indicators.rsi > 60) {
                score += 10;
                details.push('‚úì RSI Bearish');
            } else if (indicators.rsi > 50) {
                score += 5;
                details.push('‚óã RSI Neutral-');
            }
        }
        
        // MACD Score (0-15 points)
        maxScore += 15;
        if (indicators.macdHistogram) {
            const currentHist = indicators.macdHistogram[indicators.macdHistogram.length - 1];
            const prevHist = indicators.macdHistogram[indicators.macdHistogram.length - 2];
            
            if (signal === 'BUY' && currentHist > 0 && currentHist > prevHist) {
                score += 15;
                details.push('‚úì MACD Bullish Cross');
            } else if (signal === 'SELL' && currentHist < 0 && currentHist < prevHist) {
                score += 15;
                details.push('‚úì MACD Bearish Cross');
            } else if ((signal === 'BUY' && currentHist > 0) || (signal === 'SELL' && currentHist < 0)) {
                score += 8;
                details.push('‚óã MACD Aligned');
            }
        }
        
        // Stochastic Score (0-10 points)
        maxScore += 10;
        if (indicators.stochastic) {
            const k = indicators.stochastic.k[indicators.stochastic.k.length - 1];
            if (signal === 'BUY' && k < 20) {
                score += 10;
                details.push('‚úì Stoch Oversold');
            } else if (signal === 'SELL' && k > 80) {
                score += 10;
                details.push('‚úì Stoch Overbought');
            } else if ((signal === 'BUY' && k < 50) || (signal === 'SELL' && k > 50)) {
                score += 5;
                details.push('‚óã Stoch Aligned');
            }
        }
        
        // Bollinger Bands Score (0-10 points)
        maxScore += 10;
        if (indicators.bb) {
            const price = indicators.currentPrice;
            const upper = indicators.bb.upper[indicators.bb.upper.length - 1];
            const lower = indicators.bb.lower[indicators.bb.lower.length - 1];
            const middle = indicators.bb.middle[indicators.bb.middle.length - 1];
            
            if (signal === 'BUY' && price < lower) {
                score += 10;
                details.push('‚úì Price at BB Lower');
            } else if (signal === 'SELL' && price > upper) {
                score += 10;
                details.push('‚úì Price at BB Upper');
            } else if ((signal === 'BUY' && price < middle) || (signal === 'SELL' && price > middle)) {
                score += 5;
                details.push('‚óã BB Position OK');
            }
        }
        
        // ADX Trend Strength (0-15 points)
        maxScore += 15;
        if (indicators.adx) {
            if (indicators.adx.adx > 25) {
                if (signal === 'BUY' && indicators.adx.plusDI > indicators.adx.minusDI) {
                    score += 15;
                    details.push('‚úì Strong Uptrend (ADX)');
                } else if (signal === 'SELL' && indicators.adx.minusDI > indicators.adx.plusDI) {
                    score += 15;
                    details.push('‚úì Strong Downtrend (ADX)');
                } else {
                    score += 8;
                    details.push('‚óã Trending Market');
                }
            } else {
                details.push('‚ö† Weak Trend');
            }
        }
        
        // CCI Score (0-10 points)
        maxScore += 10;
        if (indicators.cci) {
            const cci = indicators.cci[indicators.cci.length - 1];
            if (signal === 'BUY' && cci < -100) {
                score += 10;
                details.push('‚úì CCI Oversold');
            } else if (signal === 'SELL' && cci > 100) {
                score += 10;
                details.push('‚úì CCI Overbought');
            } else if ((signal === 'BUY' && cci < 0) || (signal === 'SELL' && cci > 0)) {
                score += 5;
                details.push('‚óã CCI Aligned');
            }
        }
        
        // EMA/LWMA Cross Score (0-20 points)
        maxScore += 20;
        if (indicators.isCross) {
            score += 20;
            details.push('‚úì‚úì EMA/LWMA Cross!');
        } else if ((signal === 'BUY' && indicators.ema > indicators.lwma) || 
                  (signal === 'SELL' && indicators.ema < indicators.lwma)) {
            score += 10;
            details.push('‚úì EMA/LWMA Aligned');
        }
        
        // Volume Profile Score (0-10 points)
        maxScore += 10;
        if (indicators.volumeProfile) {
            const price = indicators.currentPrice;
            const poc = indicators.volumeProfile.poc;
            const distanceFromPOC = Math.abs(price - poc) / price;
            
            if (distanceFromPOC < 0.002) {
                score += 10;
                details.push('‚úì At Volume POC');
            } else if (distanceFromPOC < 0.005) {
                score += 5;
                details.push('‚óã Near Volume POC');
            }
        }
        
        const percentage = (score / maxScore) * 100;
        
        return {
            score: score,
            maxScore: maxScore,
            percentage: percentage.toFixed(1),
            details: details,
            quality: percentage >= 75 ? 'EXCELLENT' : 
                    percentage >= 60 ? 'GOOD' : 
                    percentage >= 45 ? 'MODERATE' : 'WEAK'
        };
    }

    // ==================== HELPER FUNCTIONS ====================

    function getIntervalSeconds(interval) {
        if (interval === 'D') return 86400;
        return parseInt(interval) * 60;
    }

    async function generateRealisticData(currentPrice, interval, limit) {
        const prices = [];
        const high = [];
        const low = [];
        const timestamp = [];
        
        const intervalSeconds = getIntervalSeconds(interval);
        const volatility = Math.sqrt(intervalSeconds / 60) * 2;
        
        let price = currentPrice * (0.98 + Math.random() * 0.04);
        
        for (let i = 0; i < limit; i++) {
            const progress = i / limit;
            const trendTowardsCurrent = (currentPrice - price) * 0.02;
            const cyclicalWave = Math.sin(i / 15) * volatility * 0.5;
            const randomWalk = (Math.random() - 0.5) * volatility;
            const momentum = (prices.length > 1) ? (prices[prices.length - 1] - prices[prices.length - 2]) * 0.3 : 0;
            
            price = price + trendTowardsCurrent + cyclicalWave + randomWalk + momentum;
            
            if (i >= limit - 3) {
                const convergence = 1 - (limit - i) / 3;
                price = price * (1 - convergence) + currentPrice * convergence;
            }
            
            if (i === limit - 1) {
                price = currentPrice;
            }
            
            const wickSize = volatility * (0.3 + Math.random() * 0.3);
            const candleHigh = price + wickSize;
            const candleLow = price - wickSize;
            
            prices.push(price);
            high.push(candleHigh);
            low.push(candleLow);
            timestamp.push(Date.now() / 1000 - (limit - i) * intervalSeconds);
        }
        
        return { prices, high, low, timestamp };
    }

    async function fetchTradingViewData(interval, limit = 200) {
        return await generateRealisticData(currentPrice, interval, limit);
    }

    function calculateRSI(prices, period = 14) {
        if (prices.length < period + 1) return null;
        
        let gains = 0;
        let losses = 0;
        
        for (let i = 1; i <= period; i++) {
            const change = prices[i] - prices[i - 1];
            if (change > 0) gains += change;
            else losses -= change;
        }
        
        let avgGain = gains / period;
        let avgLoss = losses / period;
        
        if (avgLoss === 0) return [100];
        
        const rsiValues = [100 - (100 / (1 + avgGain / avgLoss))];
        
        for (let i = period + 1; i < prices.length; i++) {
            const change = prices[i] - prices[i - 1];
            const gain = change > 0 ? change : 0;
            const loss = change < 0 ? -change : 0;
            
            avgGain = (avgGain * (period - 1) + gain) / period;
            avgLoss = (avgLoss * (period - 1) + loss) / period;
            
            if (avgLoss === 0) {
                rsiValues.push(100);
            } else {
                rsiValues.push(100 - (100 / (1 + avgGain / avgLoss)));
            }
        }
        
        return rsiValues;
    }

    function calculateEMA(values, period) {
        if (!values || values.length === 0) return [];
        const k = 2 / (period + 1);
        const ema = [values[0]];
        for (let i = 1; i < values.length; i++) {
            ema.push(values[i] * k + ema[i - 1] * (1 - k));
        }
        return ema;
    }

    function calculateLWMA(values, period) {
        if (!values || values.length < period) return [];
        const lwma = [];
        const denominator = (period * (period + 1)) / 2;
        for (let i = period - 1; i < values.length; i++) {
            let sum = 0;
            for (let j = 0; j < period; j++) {
                sum += values[i - j] * (period - j);
            }
            lwma.push(sum / denominator);
        }
        return lwma;
    }

    function calculateATR(high, low, close, period = 14) {
        const tr = [];
        for (let i = 1; i < high.length; i++) {
            const h_l = high[i] - low[i];
            const h_pc = Math.abs(high[i] - close[i - 1]);
            const l_pc = Math.abs(low[i] - close[i - 1]);
            tr.push(Math.max(h_l, h_pc, l_pc));
        }
        if (tr.length < period) return 10;
        let atr = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = period; i < tr.length; i++) {
            atr = (atr * (period - 1) + tr[i]) / period;
        }
        return atr;
    }

    // ==================== TP/SL CALCULATION ====================
    
    function calculateSwingPoints(prices, lookback = 50) {
        const recentPrices = prices.slice(-lookback);
        const swingHigh = Math.max(...recentPrices);
        const swingLow = Math.min(...recentPrices);
        return { swingHigh, swingLow };
    }
    
    function calculateFibonacciLevels(swingHigh, swingLow, direction) {
        const range = swingHigh - swingLow;
        if (direction === 'BUY') {
            return {
                fib_236: swingLow + range * 0.236,
                fib_382: swingLow + range * 0.382,
                fib_500: swingLow + range * 0.500,
                fib_618: swingLow + range * 0.618,
                fib_786: swingLow + range * 0.786,
                fib_1000: swingHigh,
                fib_1272: swingHigh + range * 0.272,
                fib_1618: swingHigh + range * 0.618
            };
        } else {
            return {
                fib_236: swingHigh - range * 0.236,
                fib_382: swingHigh - range * 0.382,
                fib_500: swingHigh - range * 0.500,
                fib_618: swingHigh - range * 0.618,
                fib_786: swingHigh - range * 0.786,
                fib_1000: swingLow,
                fib_1272: swingLow - range * 0.272,
                fib_1618: swingLow - range * 0.618
            };
        }
    }
    
    function findSupportResistance(prices, currentPrice, tolerance = 0.002) {
        const levels = [];
        const priceRange = Math.max(...prices) - Math.min(...prices);
        const clusterTolerance = priceRange * tolerance;
        
        for (let i = 5; i < prices.length - 5; i++) {
            const isHigh = prices[i] > prices[i-1] && prices[i] > prices[i-2] && 
                          prices[i] > prices[i+1] && prices[i] > prices[i+2];
            const isLow = prices[i] < prices[i-1] && prices[i] < prices[i-2] && 
                         prices[i] < prices[i+1] && prices[i] < prices[i+2];
            
            if (isHigh || isLow) {
                levels.push(prices[i]);
            }
        }
        
        const clusteredLevels = [];
        levels.sort((a, b) => a - b);
        
        for (let level of levels) {
            const existing = clusteredLevels.find(l => Math.abs(l - level) < clusterTolerance);
            if (!existing) {
                clusteredLevels.push(level);
            }
        }
        
        const resistance = clusteredLevels.filter(l => l > currentPrice).sort((a, b) => a - b)[0];
        const support = clusteredLevels.filter(l => l < currentPrice).sort((a, b) => b - a)[0];
        
        return { support, resistance, allLevels: clusteredLevels };
    }
    
    function calculateAdvancedTPSL(signal, entry, prices, rsiValues, atr, high, low) {
        if (signal === 'NEUTRAL') {
            return { tp: entry, sl: entry, method: 'Neutral - No Trade' };
        }
        
        const currentRSI = rsiValues[rsiValues.length - 1];
        const { swingHigh, swingLow } = calculateSwingPoints(prices);
        const srLevels = findSupportResistance(prices, entry);
        
        let tpCandidates = [];
        let slCandidates = [];
        
        if (signal === 'BUY') {
            tpCandidates.push({ value: entry + (atr * 2), weight: 1.0, name: 'ATR 2x' });
            slCandidates.push({ value: entry - (atr * 1), weight: 1.0, name: 'ATR 1x' });
            
            if (currentRSI < 30) {
                const rsiTarget = entry * 1.015;
                tpCandidates.push({ value: rsiTarget, weight: 1.5, name: 'RSI Target 70' });
                slCandidates.push({ value: entry * 0.995, weight: 1.2, name: 'RSI SL' });
            } else if (currentRSI < 50) {
                tpCandidates.push({ value: entry * 1.01, weight: 1.2, name: 'RSI Target 60' });
                slCandidates.push({ value: entry * 0.997, weight: 1.0, name: 'RSI SL' });
            }
            
            const fibs = calculateFibonacciLevels(swingHigh, swingLow, 'BUY');
            if (fibs.fib_1618 > entry) {
                tpCandidates.push({ value: fibs.fib_1618, weight: 1.3, name: 'Fib 161.8%' });
            }
            if (fibs.fib_1272 > entry) {
                tpCandidates.push({ value: fibs.fib_1272, weight: 1.2, name: 'Fib 127.2%' });
            }
            if (fibs.fib_382 < entry) {
                slCandidates.push({ value: fibs.fib_382, weight: 1.1, name: 'Fib 38.2% SL' });
            }
            
            if (srLevels.resistance && srLevels.resistance > entry) {
                const distanceToR = srLevels.resistance - entry;
                if (distanceToR > atr * 0.5) {
                    tpCandidates.push({ 
                        value: srLevels.resistance - (atr * 0.2),
                        weight: 2.0, 
                        name: 'Resistance' 
                    });
                }
            }
            if (srLevels.support && srLevels.support < entry) {
                slCandidates.push({ 
                    value: srLevels.support - (atr * 0.1),
                    weight: 2.0, 
                    name: 'Support' 
                });
            }
            
            tpCandidates.push({ value: entry * 1.012, weight: 0.8, name: '1.2% Gain' });
            slCandidates.push({ value: entry * 0.994, weight: 0.8, name: '0.6% Loss' });
            
            if (swingHigh > entry) {
                tpCandidates.push({ value: swingHigh, weight: 1.5, name: 'Swing High' });
            }
            slCandidates.push({ value: swingLow - (atr * 0.2), weight: 1.3, name: 'Swing Low' });
            
            const ema20 = calculateEMA(prices, 20);
            const currentEMA20 = ema20[ema20.length - 1];
            if (currentEMA20 < entry) {
                slCandidates.push({ value: currentEMA20, weight: 1.2, name: 'EMA20 Trail' });
            }
            
        } else if (signal === 'SELL') {
            tpCandidates.push({ value: entry - (atr * 2), weight: 1.0, name: 'ATR 2x' });
            slCandidates.push({ value: entry + (atr * 1), weight: 1.0, name: 'ATR 1x' });
            
            if (currentRSI > 70) {
                const rsiTarget = entry * 0.985;
                tpCandidates.push({ value: rsiTarget, weight: 1.5, name: 'RSI Target 30' });
                slCandidates.push({ value: entry * 1.005, weight: 1.2, name: 'RSI SL' });
            } else if (currentRSI > 50) {
                tpCandidates.push({ value: entry * 0.99, weight: 1.2, name: 'RSI Target 40' });
                slCandidates.push({ value: entry * 1.003, weight: 1.0, name: 'RSI SL' });
            }
            
            const fibs = calculateFibonacciLevels(swingHigh, swingLow, 'SELL');
            if (fibs.fib_1618 < entry) {
                tpCandidates.push({ value: fibs.fib_1618, weight: 1.3, name: 'Fib 161.8%' });
            }
            if (fibs.fib_1272 < entry) {
                tpCandidates.push({ value: fibs.fib_1272, weight: 1.2, name: 'Fib 127.2%' });
            }
            if (fibs.fib_382 > entry) {
                slCandidates.push({ value: fibs.fib_382, weight: 1.1, name: 'Fib 38.2% SL' });
            }
            
            if (srLevels.support && srLevels.support < entry) {
                const distanceToS = entry - srLevels.support;
                if (distanceToS > atr * 0.5) {
                    tpCandidates.push({ 
                        value: srLevels.support + (atr * 0.2),
                        weight: 2.0, 
                        name: 'Support' 
                    });
                }
            }
            if (srLevels.resistance && srLevels.resistance > entry) {
                slCandidates.push({ 
                    value: srLevels.resistance + (atr * 0.1),
                    weight: 2.0, 
                    name: 'Resistance' 
                });
            }
            
            tpCandidates.push({ value: entry * 0.988, weight: 0.8, name: '1.2% Gain' });
            slCandidates.push({ value: entry * 1.006, weight: 0.8, name: '0.6% Loss' });
            
            if (swingLow < entry) {
                tpCandidates.push({ value: swingLow, weight: 1.5, name: 'Swing Low' });
            }
            slCandidates.push({ value: swingHigh + (atr * 0.2), weight: 1.3, name: 'Swing High' });
            
            const ema20 = calculateEMA(prices, 20);
            const currentEMA20 = ema20[ema20.length - 1];
            if (currentEMA20 > entry) {
                slCandidates.push({ value: currentEMA20, weight: 1.2, name: 'EMA20 Trail' });
            }
        }
        
        const calculateWeightedAverage = (candidates) => {
            if (candidates.length === 0) return null;
            let sumWeightedValues = 0;
            let sumWeights = 0;
            candidates.forEach(c => {
                sumWeightedValues += c.value * c.weight;
                sumWeights += c.weight;
            });
            return sumWeightedValues / sumWeights;
        };
        
        const tp = calculateWeightedAverage(tpCandidates);
        const sl = calculateWeightedAverage(slCandidates);
        
        const tpMethods = tpCandidates.map(c => c.name).join(', ');
        const slMethods = slCandidates.map(c => c.name).join(', ');
        
        let finalTP = tp;
        let finalSL = sl;
        
        const risk = Math.abs(entry - sl);
        const reward = Math.abs(tp - entry);
        const rrRatio = reward / risk;
        
        if (rrRatio < 1.5) {
            if (signal === 'BUY') {
                finalTP = entry + (risk * 2);
            } else {
                finalTP = entry - (risk * 2);
            }
        }
        
        return {
            tp: finalTP,
            sl: finalSL,
            rrRatio: ((Math.abs(finalTP - entry)) / Math.abs(entry - finalSL)).toFixed(2),
            tpMethods: tpMethods,
            slMethods: slMethods,
            tpCount: tpCandidates.length,
            slCount: slCandidates.length
        };
    }

    // ==================== MAIN ANALYSIS ====================

    async function analyzeTimeframe(tf) {
        const data = await fetchTradingViewData(tf.interval);
        const prices = data.prices;
        
        const rsiValues = calculateRSI(prices, 14);
        if (!rsiValues || rsiValues.length < 50) return null;
        
        const emaOnRsi = calculateEMA(rsiValues, 9);
        const lwmaOnRsi = calculateLWMA(rsiValues, 45);
        if (lwmaOnRsi.length === 0) return null;
        
        const currentRSI = rsiValues[rsiValues.length - 1];
        const currentEMA = emaOnRsi[emaOnRsi.length - 1];
        const currentLWMA = lwmaOnRsi[lwmaOnRsi.length - 1];
        const prevEMA = emaOnRsi[emaOnRsi.length - 2];
        const prevLWMA = lwmaOnRsi[lwmaOnRsi.length - 2];
        
        // Calculate additional indicators
        const macd = calculateMACD(prices);
        const bb = calculateBollingerBands(prices);
        const stochastic = calculateStochastic(data.high, data.low, prices);
        const adx = calculateADX(data.high, data.low, prices);
        const cci = calculateCCI(data.high, data.low, prices);
        const volumeProfile = detectVolumeProfile(prices);
        
        let signal = 'NEUTRAL';
        let signalStrength = 0;
        
        const emaCrossAbove = prevEMA <= prevLWMA && currentEMA > currentLWMA;
        const emaCrossBelow = prevEMA >= prevLWMA && currentEMA < currentLWMA;
        
        if (emaCrossAbove) {
            signal = 'BUY';
            signalStrength = Math.abs(currentEMA - currentLWMA);
        } else if (emaCrossBelow) {
            signal = 'SELL';
            signalStrength = Math.abs(currentEMA - currentLWMA);
        } else {
            if (currentEMA > currentLWMA) {
                signal = 'BUY';
                signalStrength = (currentEMA - currentLWMA) * 0.5;
            } else if (currentEMA < currentLWMA) {
                signal = 'SELL';
                signalStrength = (currentLWMA - currentEMA) * 0.5;
            }
        }
        
        const currentMarketPrice = prices[prices.length - 1];
        const atr = calculateATR(data.high, data.low, prices, 14);
        
        // Prepare indicators object for confluence scoring
        const indicators = {
            rsi: currentRSI,
            ema: currentEMA,
            lwma: currentLWMA,
            isCross: emaCrossAbove || emaCrossBelow,
            macdHistogram: macd.histogram,
            bb: bb,
            stochastic: stochastic,
            adx: adx,
            cci: cci,
            volumeProfile: volumeProfile,
            currentPrice: currentMarketPrice
        };
        
        const confluence = calculateConfluenceScore(indicators, signal);
        const tpslData = calculateAdvancedTPSL(signal, currentMarketPrice, prices, rsiValues, atr, data.high, data.low);
        
        return {
            timeframe: tf.label,
            rsi: currentRSI.toFixed(2),
            ema: currentEMA.toFixed(2),
            lwma: currentLWMA.toFixed(2),
            macd: macd.histogram[macd.histogram.length - 1].toFixed(4),
            stoch: stochastic.k[stochastic.k.length - 1].toFixed(2),
            adxValue: adx.adx.toFixed(2),
            cci: cci[cci.length - 1].toFixed(2),
            signal: signal,
            signalStrength: signalStrength,
            confluence: confluence,
            entry: currentMarketPrice.toFixed(2),
            tp: tpslData.tp.toFixed(2),
            sl: tpslData.sl.toFixed(2),
            rrRatio: tpslData.rrRatio,
            tpMethods: tpslData.tpMethods,
            slMethods: tpslData.slMethods,
            methodCount: `TP:${tpslData.tpCount} SL:${tpslData.slCount}`,
            isCross: emaCrossAbove || emaCrossBelow
        };
    }

    async function analyzeMarket() {
        document.getElementById('loadingIndicator').style.display = 'block';
        document.getElementById('analysisGrid').innerHTML = '';
        document.getElementById('summarySection').style.display = 'none';
        
        const results = [];
        
        for (const tf of timeframes) {
            const analysis = await analyzeTimeframe(tf);
            if (analysis) {
                results.push(analysis);
                displayTimeframeAnalysis(analysis);
            }
        }
        
        displaySummary(results);
        
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('lastUpdate').textContent = 
            `Ph√¢n t√≠ch l·∫ßn cu·ªëi: ${new Date().toLocaleString('vi-VN')}`;
    }

    function displayTimeframeAnalysis(analysis) {
        const grid = document.getElementById('analysisGrid');
        const card = document.createElement('div');
        card.className = 'timeframe-card';
        
        const signalClass = analysis.signal.toLowerCase();
        const signalIcon = analysis.signal === 'BUY' ? 'üìà' : 
                          analysis.signal === 'SELL' ? 'üìâ' : '‚ûñ';
        const crossIndicator = analysis.isCross ? ' üî• (C·∫ÆT NHAU!)' : '';
        
        const entry = parseFloat(analysis.entry);
        const tp = parseFloat(analysis.tp);
        const sl = parseFloat(analysis.sl);
        const tpPips = Math.abs(tp - entry).toFixed(2);
        const slPips = Math.abs(sl - entry).toFixed(2);
        const tpPercent = ((Math.abs(tp - entry) / entry) * 100).toFixed(2);
        const slPercent = ((Math.abs(sl - entry) / entry) * 100).toFixed(2);
        
        const confluence = analysis.confluence;
        const strengthClass = confluence.percentage >= 60 ? 'strong' : 
                             confluence.percentage >= 45 ? 'medium' : 'weak';
        
        card.innerHTML = `
            <div class="timeframe-header">${analysis.timeframe}</div>
            
            <div class="confluence-score">
                <div style="font-size: 0.9em; opacity: 0.9;">Confluence Score</div>
                <div class="score-value">${confluence.percentage}%</div>
                <div style="font-size: 1.1em; margin-top: 5px;">${confluence.quality}</div>
                <div class="confluence-details">${confluence.score}/${confluence.maxScore} points</div>
            </div>
            
            <div class="indicator-values">
                <div class="indicator-row">
                    <span class="indicator-label">RSI(14):</span>
                    <span class="indicator-value">${analysis.rsi}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">EMA(9) on RSI:</span>
                    <span class="indicator-value">${analysis.ema}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">LWMA(45) on RSI:</span>
                    <span class="indicator-value">${analysis.lwma}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">MACD Histogram:</span>
                    <span class="indicator-value">${analysis.macd}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">Stochastic:</span>
                    <span class="indicator-value">${analysis.stoch}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">ADX:</span>
                    <span class="indicator-value">${analysis.adxValue}</span>
                </div>
                <div class="indicator-row">
                    <span class="indicator-label">CCI:</span>
                    <span class="indicator-value">${analysis.cci}</span>
                </div>
            </div>
            
            <div class="signal-strength-bar">
                <div class="strength-label">Signal Strength:</div>
                <div class="strength-bar">
                    <div class="strength-fill ${strengthClass}" style="width: ${confluence.percentage}%">
                        ${confluence.percentage}%
                    </div>
                </div>
            </div>
            
            <div class="signal ${signalClass}">
                ${signalIcon} ${analysis.signal}${crossIndicator}
            </div>
            
            <div style="margin-top: 15px; padding: 12px; background: #f0f8ff; border-radius: 8px; font-size: 0.85em;">
                <strong>‚úì Indicators Aligned:</strong>
                <div style="margin-top: 8px; line-height: 1.6;">
                    ${confluence.details.map(d => `<div>${d}</div>`).join('')}
                </div>
            </div>
            
            <div class="trade-levels">
                <div class="level-row entry">
                    <span>üìç Entry:</span>
                    <span>$${analysis.entry}</span>
                </div>
                <div class="level-row tp">
                    <span>üéØ TP:</span>
                    <span>$${analysis.tp} (+${tpPips} / ${tpPercent}%)</span>
                </div>
                <div class="level-row sl">
                    <span>üõë SL:</span>
                    <span>$${analysis.sl} (-${slPips} / ${slPercent}%)</span>
                </div>
                <div class="indicator-row" style="margin-top: 10px; background: #fff3cd; border-left: 4px solid #ffc107;">
                    <span class="indicator-label">‚öñÔ∏è R:R Ratio:</span>
                    <span class="indicator-value" style="color: #856404; font-size: 1.1em;">1:${analysis.rrRatio}</span>
                </div>
            </div>
            
            <div style="margin-top: 15px; padding: 12px; background: #e7f3ff; border-radius: 8px; font-size: 0.85em;">
                <div style="margin-bottom: 8px;">
                    <strong>üéØ TP Methods (${analysis.methodCount.split(' ')[0].split(':')[1]}):</strong>
                    <div style="color: #0066cc; margin-top: 4px;">${analysis.tpMethods || 'ATR-based'}</div>
                </div>
                <div>
                    <strong>üõë SL Methods (${analysis.methodCount.split(' ')[1].split(':')[1]}):</strong>
                    <div style="color: #cc0000; margin-top: 4px;">${analysis.slMethods || 'ATR-based'}</div>
                </div>
            </div>
        `;
        
        grid.appendChild(card);
    }

    function displaySummary(results) {
        const buyCount = results.filter(r => r.signal === 'BUY').length;
        const sellCount = results.filter(r => r.signal === 'SELL').length;
        const neutralCount = results.filter(r => r.signal === 'NEUTRAL').length;
        
        const avgConfluence = results.reduce((sum, r) => sum + parseFloat(r.confluence.percentage), 0) / results.length;
        const strongSignals = results.filter(r => parseFloat(r.confluence.percentage) >= 60).length;
        
        let overallSignal = 'NEUTRAL';
        if (buyCount > sellCount + neutralCount) overallSignal = 'BUY';
        else if (sellCount > buyCount + neutralCount) overallSignal = 'SELL';
        
        const summaryContent = document.getElementById('summaryContent');
        summaryContent.innerHTML = `
            <p><strong>T·ªïng s·ªë khung ph√¢n t√≠ch:</strong> ${results.length}</p>
            <p><strong>üìà T√≠n hi·ªáu BUY:</strong> ${buyCount} khung</p>
            <p><strong>üìâ T√≠n hi·ªáu SELL:</strong> ${sellCount} khung</p>
            <p><strong>‚ûñ T√≠n hi·ªáu NEUTRAL:</strong> ${neutralCount} khung</p>
            <p><strong>üí™ T√≠n hi·ªáu m·∫°nh (‚â•60%):</strong> ${strongSignals} khung</p>
            <p><strong>üìä ƒê·ªô ch√≠nh x√°c trung b√¨nh:</strong> ${avgConfluence.toFixed(1)}%</p>
            <p style="margin-top: 15px; font-size: 1.2em;">
                <strong>üéØ Xu h∆∞·ªõng chung: ${overallSignal}</strong>
            </p>
            <p style="margin-top: 10px; font-size: 0.95em; opacity: 0.9;">
                ${overallSignal === 'BUY' ? '‚úÖ ƒêa s·ªë khung th·ªùi gian ƒëang c√≥ xu h∆∞·ªõng tƒÉng' :
                  overallSignal === 'SELL' ? '‚ö†Ô∏è ƒêa s·ªë khung th·ªùi gian ƒëang c√≥ xu h∆∞·ªõng gi·∫£m' :
                  '‚öñÔ∏è Th·ªã tr∆∞·ªùng ƒëang trong tr·∫°ng th√°i trung l·∫≠p'}
            </p>
        `;
        
        document.getElementById('summarySection').style.display = 'block';
    }

    function toggleAutoRefresh() {
        isAutoRefreshEnabled = !isAutoRefreshEnabled;
        const btn = document.getElementById('autoRefreshBtn');
        
        if (isAutoRefreshEnabled) {
            btn.innerHTML = '‚è∏Ô∏è T·∫°m d·ª´ng';
            startAutoRefresh();
        } else {
            btn.innerHTML = '‚ñ∂Ô∏è Ti·∫øp t·ª•c';
            stopAutoRefresh();
        }
    }

    function startAutoRefresh() {
        priceInterval = setInterval(updatePriceRealtime, 1000);
        analysisInterval = setInterval(analyzeMarket, 30000);
    }

    function stopAutoRefresh() {
        if (priceInterval) clearInterval(priceInterval);
        if (analysisInterval) clearInterval(analysisInterval);
    }

    window.onload = async function() {
        await updatePriceRealtime();
        await analyzeMarket();
        startAutoRefresh();
    };

    window.onbeforeunload = function() {
        stopAutoRefresh();
    };
</script>
```

</body>
</html>



