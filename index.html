<!DOCTYPE html>

<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Asset Real-Time Analysis - Smart Entry</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        min-height: 100vh;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        overflow: hidden;
    }
    
    .header {
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        color: white;
        padding: 30px;
        text-align: center;
    }
    
    .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .asset-selector {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 20px 0;
    }
    
    .asset-btn {
        background: rgba(255,255,255,0.2);
        color: white;
        border: 2px solid rgba(255,255,255,0.3);
        padding: 12px 30px;
        font-size: 16px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: bold;
    }
    
    .asset-btn:hover {
        background: rgba(255,255,255,0.3);
        transform: translateY(-2px);
    }
    
    .asset-btn.active {
        background: rgba(255,255,255,0.95);
        color: #1e3c72;
        border-color: white;
        box-shadow: 0 4px 15px rgba(255,255,255,0.4);
    }
    
    .price-display {
        background: rgba(255,255,255,0.1);
        padding: 20px;
        border-radius: 10px;
        margin-top: 15px;
        display: inline-block;
        min-width: 400px;
    }
    
    .price-row {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        font-size: 1.5em;
    }
    
    .price-label {
        color: rgba(255,255,255,0.8);
    }
    
    .price-value {
        font-weight: bold;
        color: #ffd700;
        font-family: 'Courier New', monospace;
        transition: all 0.3s ease;
    }
    
    .price-value.flash-up {
        animation: flashGreen 0.5s;
    }
    
    .price-value.flash-down {
        animation: flashRed 0.5s;
    }
    
    @keyframes flashGreen {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(46, 204, 113, 0.3); }
    }
    
    @keyframes flashRed {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(231, 76, 60, 0.3); }
    }
    
    .main-price {
        font-size: 3em !important;
        font-weight: bold;
        color: #ffd700;
        text-align: center;
        margin: 10px 0;
    }
    
    .price-change {
        text-align: center;
        font-size: 1.2em;
        margin-top: 5px;
    }
    
    .price-source {
        font-size: 0.9em;
        margin-top: 10px;
        opacity: 0.8;
        text-align: center;
    }
    
    .live-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        background: #2ecc71;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
        margin-right: 8px;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }
    
    .controls {
        padding: 20px 30px;
        background: #f8f9fa;
        border-bottom: 2px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 30px;
        font-size: 16px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    
    .btn:active {
        transform: translateY(0);
    }
    
    .refresh-status {
        color: #666;
        font-size: 14px;
    }
    
    .analysis-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 25px;
        padding: 30px;
    }
    
    .timeframe-card {
        background: white;
        border-radius: 12px;
        padding: 25px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        border: 2px solid #e9ecef;
        transition: all 0.3s;
    }
    
    .timeframe-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    }
    
    .timeframe-header {
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 3px solid #667eea;
        color: #2c3e50;
    }
    
    .indicator-values {
        margin: 15px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
    }
    
    .indicator-row {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        padding: 8px;
        background: white;
        border-radius: 5px;
    }
    
    .indicator-label {
        font-weight: 600;
        color: #495057;
    }
    
    .indicator-value {
        font-weight: bold;
        color: #2c3e50;
    }
    
    .signal {
        margin-top: 20px;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-size: 1.3em;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .signal.buy {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
    }
    
    .signal.sell {
        background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        color: white;
        box-shadow: 0 5px 15px rgba(235, 51, 73, 0.4);
    }
    
    .signal.neutral {
        background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%);
        color: white;
    }
    
    .trade-levels {
        margin-top: 15px;
        padding: 15px;
        background: #e9ecef;
        border-radius: 8px;
    }
    
    .level-row {
        display: flex;
        justify-content: space-between;
        margin: 8px 0;
        padding: 10px;
        background: white;
        border-radius: 5px;
        font-weight: 600;
    }
    
    .level-row.current {
        border-left: 4px solid #95a5a6;
        background: #f8f9fa;
    }
    
    .level-row.entry-market {
        border-left: 4px solid #e74c3c;
        background: #ffebee;
    }
    
    .level-row.entry-limit {
        border-left: 4px solid #3498db;
        background: #e3f2fd;
    }
    
    .level-row.entry-stop {
        border-left: 4px solid #f39c12;
        background: #fff3e0;
    }
    
    .level-row.tp {
        border-left: 4px solid #2ecc71;
    }
    
    .level-row.sl {
        border-left: 4px solid #e74c3c;
    }
    
    .entry-type-badge {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 0.75em;
        margin-left: 8px;
        font-weight: bold;
    }
    
    .badge-market {
        background: #e74c3c;
        color: white;
    }
    
    .badge-limit {
        background: #3498db;
        color: white;
    }
    
    .badge-stop {
        background: #f39c12;
        color: white;
    }
    
    .entry-explanation {
        margin-top: 10px;
        padding: 12px;
        background: #fff9e6;
        border-radius: 8px;
        font-size: 0.85em;
        border-left: 4px solid #ffc107;
    }
    
    .loading {
        text-align: center;
        padding: 40px;
        font-size: 1.2em;
        color: #666;
    }
    
    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #667eea;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .last-update {
        text-align: center;
        padding: 15px;
        color: #666;
        font-style: italic;
        background: #f8f9fa;
        border-top: 2px solid #dee2e6;
    }
    
    .summary {
        padding: 30px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        margin: 30px;
        border-radius: 12px;
        box-shadow: 0 5px 20px rgba(245, 87, 108, 0.3);
    }
    
    .summary h2 {
        margin-bottom: 15px;
        font-size: 1.8em;
    }
    
    .summary-content {
        font-size: 1.1em;
        line-height: 1.6;
    }
    
    .spread-info {
        font-size: 0.9em;
        color: rgba(255,255,255,0.8);
        margin-top: 5px;
    }

    .signal-strength-bar {
        margin-top: 15px;
        padding: 15px;
        background: white;
        border-radius: 8px;
    }

    .strength-label {
        font-size: 0.9em;
        color: #495057;
        margin-bottom: 8px;
        font-weight: 600;
    }

    .strength-bar {
        height: 25px;
        background: #e9ecef;
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }

    .strength-fill {
        height: 100%;
        transition: width 0.5s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 0.85em;
    }

    .strength-fill.strong {
        background: linear-gradient(90deg, #11998e 0%, #38ef7d 100%);
    }

    .strength-fill.medium {
        background: linear-gradient(90deg, #f39c12 0%, #f1c40f 100%);
    }

    .strength-fill.weak {
        background: linear-gradient(90deg, #95a5a6 0%, #bdc3c7 100%);
    }

    .confluence-score {
        margin-top: 15px;
        padding: 15px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 8px;
        color: white;
        text-align: center;
    }

    .confluence-score .score-value {
        font-size: 2em;
        font-weight: bold;
        margin: 10px 0;
    }

    .confluence-details {
        font-size: 0.85em;
        margin-top: 10px;
        opacity: 0.9;
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Multi-Asset Real-Time Analysis - Smart Entry</h1>

```
        <div class="asset-selector">
            <button class="asset-btn active" onclick="switchAsset('XAUUSD')" id="btnXAUUSD">
                ü•á XAU/USD (Gold)
            </button>
            <button class="asset-btn" onclick="switchAsset('BTCUSD')" id="btnBTCUSD">
                ‚Çø BTC/USD (Bitcoin)
            </button>
        </div>
        
        <p style="font-size: 1.1em; margin-top: 10px;">
            <span class="live-indicator"></span>
            Multi-Entry Strategy System (Market/Limit/Stop)
        </p>
        <div class="price-display">
            <div class="main-price" id="currentPrice">Loading...</div>
            <div class="price-change" id="priceChange">--</div>
            <div class="price-row">
                <span class="price-label">Bid:</span>
                <span class="price-value" id="bidPrice">--</span>
            </div>
            <div class="price-row">
                <span class="price-label">Ask:</span>
                <span class="price-value" id="askPrice">--</span>
            </div>
            <div class="spread-info">
                Spread: <span id="spreadValue">--</span> | 
                Tick: <span id="tickCount">0</span>
            </div>
            <div class="price-source" id="priceSource">ƒêang k·∫øt n·ªëi...</div>
        </div>
    </div>

    <div class="controls">
        <div>
            <button class="btn" onclick="analyzeMarket()">üîÑ C·∫≠p Nh·∫≠t Ph√¢n T√≠ch</button>
            <button class="btn" onclick="toggleAutoRefresh()" id="autoRefreshBtn" style="margin-left: 10px;">
                ‚è∏Ô∏è T·∫°m d·ª´ng
            </button>
        </div>
        <div class="refresh-status">
            <div><span class="live-indicator"></span> C·∫≠p nh·∫≠t gi√°: <strong>1 gi√¢y</strong></div>
            <div>Ph√¢n t√≠ch: <strong id="analysisInterval">30 gi√¢y</strong></div>
        </div>
    </div>
    
    <div id="loadingIndicator" class="loading" style="display: none;">
        <div class="spinner"></div>
        <p>ƒêang ph√¢n t√≠ch th·ªã tr∆∞·ªùng...</p>
    </div>
    
    <div id="summarySection" class="summary" style="display: none;">
        <h2>üìà T·ªïng Quan T√≠n Hi·ªáu</h2>
        <div class="summary-content" id="summaryContent"></div>
    </div>
    
    <div id="analysisGrid" class="analysis-grid"></div>
    
    <div class="last-update">
        <p id="lastUpdate">Ch∆∞a c√≥ d·ªØ li·ªáu</p>
    </div>
</div>
```

<script>
    // C·∫•u h√¨nh
    const timeframes = [
        { name: 'M1', label: '1 Ph√∫t', interval: '1', multiplier: 0.0001 },
        { name: 'M5', label: '5 Ph√∫t', interval: '5', multiplier: 0.0002 },
        { name: 'M15', label: '15 Ph√∫t', interval: '15', multiplier: 0.0004 },
        { name: 'M30', label: '30 Ph√∫t', interval: '30', multiplier: 0.0006 },
        { name: 'H1', label: '1 Gi·ªù', interval: '60', multiplier: 0.001 },
        { name: 'H4', label: '4 Gi·ªù', interval: '240', multiplier: 0.002 },
        { name: 'D1', label: '1 Ng√†y', interval: 'D', multiplier: 0.005 }
    ];

    // Bi·∫øn global
    let currentAsset = 'XAUUSD';
    let currentPrice = 0;
    let bidPrice = 0;
    let askPrice = 0;
    let previousPrice = 0;
    let priceInterval;
    let analysisInterval;
    let tickCount = 0;
    let priceSource = 'Initializing...';
    let isAutoRefreshEnabled = true;
    let priceHistory = [];

    // Asset configurations
    const assetConfig = {
        'XAUUSD': {
            name: 'Gold',
            symbol: 'XAU/USD',
            basePrice: 2650,
            spread: 0.3,
            priceDecimals: 2,
            apiSymbol: 'XAU'
        },
        'BTCUSD': {
            name: 'Bitcoin',
            symbol: 'BTC/USD',
            basePrice: 97000,
            spread: 5,
            priceDecimals: 2,
            apiSymbol: 'BTC'
        }
    };

    // ==================== ASSET SWITCHING ====================
    
    async function switchAsset(asset) {
        if (currentAsset === asset) return;
        
        currentAsset = asset;
        
        // Update button states
        document.getElementById('btnXAUUSD').classList.toggle('active', asset === 'XAUUSD');
        document.getElementById('btnBTCUSD').classList.toggle('active', asset === 'BTCUSD');
        
        // Reset data
        priceHistory = [];
        tickCount = 0;
        
        // Update price first and wait for it
        await updatePriceRealtime();
        
        // Small delay to ensure price is set
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Then analyze with new price
        await analyzeMarket();
    }

    // ==================== H·ªÜ TH·ªêNG L·∫§Y GI√Å REAL-TIME ====================
    
    function generateRealisticPrice(basePrice, asset) {
        const now = Date.now();
        const secondOfDay = (now / 1000) % 86400;
        
        // Different volatility for different assets
        let volatilityMultiplier = 1;
        if (asset === 'BTCUSD') {
            volatilityMultiplier = 15; // Bitcoin is more volatile
        }
        
        const hourlyTrend = Math.sin(secondOfDay / 3600 * Math.PI / 12) * 15 * volatilityMultiplier;
        const microTrend = Math.sin(now / 1000) * 5 * volatilityMultiplier;
        const randomWalk = (Math.random() - 0.5) * 2 * volatilityMultiplier;
        
        let momentum = 0;
        if (priceHistory.length > 5) {
            const recent = priceHistory.slice(-5);
            momentum = (recent[recent.length - 1] - recent[0]) * 0.1;
        }
        
        return basePrice + hourlyTrend + microTrend + randomWalk + momentum;
    }

    async function fetchCurrentPrice() {
        const config = assetConfig[currentAsset];
        
        try {
            if (currentAsset === 'XAUUSD') {
                const response = await fetch('https://api.gold-api.com/price/XAU', {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data && data.price) {
                        priceSource = 'Gold-API (Real-time)';
                        return {
                            price: parseFloat(data.price),
                            bid: parseFloat(data.price) - 0.5,
                            ask: parseFloat(data.price) + 0.5
                        };
                    }
                }
            } else if (currentAsset === 'BTCUSD') {
                // Try CoinGecko API for Bitcoin
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
                
                if (response.ok) {
                    const data = await response.json();
                    if (data && data.bitcoin && data.bitcoin.usd) {
                        priceSource = 'CoinGecko (Real-time)';
                        const btcPrice = parseFloat(data.bitcoin.usd);
                        return {
                            price: btcPrice,
                            bid: btcPrice - 5,
                            ask: btcPrice + 5
                        };
                    }
                }
            }
        } catch (error) {
            console.log('API unavailable, using simulation');
        }

        // Fallback to simulation
        const price = generateRealisticPrice(config.basePrice, currentAsset);
        const spread = config.spread + Math.random() * (config.spread * 0.2);
        priceSource = `Simulation (Real-time Tick) - ${config.name}`;
        
        return {
            price: price,
            bid: price - spread / 2,
            ask: price + spread / 2
        };
    }

    async function updatePriceRealtime() {
        try {
            const priceData = await fetchCurrentPrice();
            previousPrice = currentPrice;
            currentPrice = priceData.price;
            bidPrice = priceData.bid;
            askPrice = priceData.ask;
            
            priceHistory.push(currentPrice);
            if (priceHistory.length > 100) {
                priceHistory.shift();
            }
            
            tickCount++;
            updatePriceDisplay();
        } catch (error) {
            console.error('Error updating price:', error);
        }
    }

    function updatePriceDisplay() {
        const config = assetConfig[currentAsset];
        const decimals = config.priceDecimals;
        
        const priceElement = document.getElementById('currentPrice');
        const bidElement = document.getElementById('bidPrice');
        const askElement = document.getElementById('askPrice');
        const changeElement = document.getElementById('priceChange');
        
        if (currentPrice > previousPrice) {
            priceElement.classList.remove('flash-down');
            priceElement.classList.add('flash-up');
            bidElement.classList.add('flash-up');
            askElement.classList.add('flash-up');
        } else if (currentPrice < previousPrice) {
            priceElement.classList.remove('flash-up');
            priceElement.classList.add('flash-down');
            bidElement.classList.add('flash-down');
            askElement.classList.add('flash-down');
        }
        
        setTimeout(() => {
            priceElement.classList.remove('flash-up', 'flash-down');
            bidElement.classList.remove('flash-up', 'flash-down');
            askElement.classList.remove('flash-up', 'flash-down');
        }, 500);
        
        priceElement.textContent = `$${currentPrice.toFixed(decimals)}`;
        bidElement.textContent = `$${bidPrice.toFixed(decimals)}`;
        askElement.textContent = `$${askPrice.toFixed(decimals)}`;
        
        const spread = (askPrice - bidPrice).toFixed(decimals);
        document.getElementById('spreadValue').textContent = `$${spread}`;
        document.getElementById('tickCount').textContent = tickCount;
        
        if (priceHistory.length > 60) {
            const priceMinuteAgo = priceHistory[priceHistory.length - 60];
            const change = currentPrice - priceMinuteAgo;
            const changePercent = ((change / priceMinuteAgo) * 100).toFixed(2);
            
            if (change > 0) {
                changeElement.innerHTML = `‚ñ≤ +$${change.toFixed(decimals)} (+${changePercent}%)`;
                changeElement.style.color = '#2ecc71';
            } else if (change < 0) {
                changeElement.innerHTML = `‚ñº $${change.toFixed(decimals)} (${changePercent}%)`;
                changeElement.style.color = '#e74c3c';
            } else {
                changeElement.innerHTML = `‚îÄ $0.00 (0.00%)`;
                changeElement.style.color = '#95a5a6';
            }
        }
        
        document.getElementById('priceSource').textContent = `${priceSource} ‚Ä¢ ${new Date().toLocaleTimeString('vi-VN')}`;
    }

    // ==================== ENHANCED TECHNICAL INDICATORS ====================

    function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
        const fastEMA = calculateEMA(prices, fastPeriod);
        const slowEMA = calculateEMA(prices, slowPeriod);
        
        const macdLine = [];
        for (let i = 0; i < fastEMA.length; i++) {
            macdLine.push(fastEMA[i] - slowEMA[i]);
        }
        
        const signalLine = calculateEMA(macdLine, signalPeriod);
        const histogram = [];
        
        for (let i = 0; i < macdLine.length; i++) {
            histogram.push(macdLine[i] - signalLine[i]);
        }
        
        return { macdLine, signalLine, histogram };
    }

    function calculateBollingerBands(prices, period = 20, stdDev = 2) {
        const sma = calculateSMA(prices, period);
        const bands = { upper: [], middle: [], lower: [] };
        
        for (let i = period - 1; i < prices.length; i++) {
            const slice = prices.slice(i - period + 1, i + 1);
            const mean = sma[i - period + 1];
            const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
            const std = Math.sqrt(variance);
            
            bands.middle.push(mean);
            bands.upper.push(mean + stdDev * std);
            bands.lower.push(mean - stdDev * std);
        }
        
        return bands;
    }

    function calculateSMA(values, period) {
        const sma = [];
        for (let i = period - 1; i < values.length; i++) {
            const sum = values.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
            sma.push(sum / period);
        }
        return sma;
    }

    function calculateStochastic(high, low, close, kPeriod = 14, dPeriod = 3) {
        const kValues = [];
        
        for (let i = kPeriod - 1; i < close.length; i++) {
            const highestHigh = Math.max(...high.slice(i - kPeriod + 1, i + 1));
            const lowestLow = Math.min(...low.slice(i - kPeriod + 1, i + 1));
            const k = ((close[i] - lowestLow) / (highestHigh - lowestLow)) * 100;
            kValues.push(k);
        }
        
        const dValues = calculateSMA(kValues, dPeriod);
        
        return { k: kValues, d: dValues };
    }

    function calculateADX(high, low, close, period = 14) {
        const tr = [];
        const plusDM = [];
        const minusDM = [];
        
        for (let i = 1; i < close.length; i++) {
            const h_l = high[i] - low[i];
            const h_pc = Math.abs(high[i] - close[i - 1]);
            const l_pc = Math.abs(low[i] - close[i - 1]);
            tr.push(Math.max(h_l, h_pc, l_pc));
            
            const highDiff = high[i] - high[i - 1];
            const lowDiff = low[i - 1] - low[i];
            
            plusDM.push(highDiff > lowDiff && highDiff > 0 ? highDiff : 0);
            minusDM.push(lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0);
        }
        
        const smoothedTR = calculateSMA(tr, period);
        const smoothedPlusDM = calculateSMA(plusDM, period);
        const smoothedMinusDM = calculateSMA(minusDM, period);
        
        const plusDI = [];
        const minusDI = [];
        const dx = [];
        
        for (let i = 0; i < smoothedTR.length; i++) {
            const pdi = (smoothedPlusDM[i] / smoothedTR[i]) * 100;
            const mdi = (smoothedMinusDM[i] / smoothedTR[i]) * 100;
            plusDI.push(pdi);
            minusDI.push(mdi);
            
            const sum = pdi + mdi;
            if (sum > 0) {
                dx.push((Math.abs(pdi - mdi) / sum) * 100);
            } else {
                dx.push(0);
            }
        }
        
        const adx = calculateSMA(dx, period);
        
        return { 
            adx: adx.length > 0 ? adx[adx.length - 1] : 0,
            plusDI: plusDI.length > 0 ? plusDI[plusDI.length - 1] : 0,
            minusDI: minusDI.length > 0 ? minusDI[minusDI.length - 1] : 0
        };
    }

    function calculateCCI(high, low, close, period = 20) {
        const tp = close.map((c, i) => (high[i] + low[i] + c) / 3);
        const sma = calculateSMA(tp, period);
        const cci = [];
        
        for (let i = period - 1; i < tp.length; i++) {
            const slice = tp.slice(i - period + 1, i + 1);
            const meanDev = slice.reduce((sum, val) => sum + Math.abs(val - sma[i - period + 1]), 0) / period;
            const cciVal = (tp[i] - sma[i - period + 1]) / (0.015 * meanDev);
            cci.push(cciVal);
        }
        
        return cci;
    }

    function detectVolumeProfile(prices, volume = null) {
        if (!volume) {
            volume = prices.map(() => 1 + Math.random());
        }
        
        const priceMin = Math.min(...prices);
        const priceMax = Math.max(...prices);
        const priceRange = priceMax - priceMin;
        const bucketSize = priceRange / 20;
        
        const volumeProfile = new Array(20).fill(0);
        
        for (let i = 0; i < prices.length; i++) {
            const bucketIndex = Math.min(Math.floor((prices[i] - priceMin) / bucketSize), 19);
            volumeProfile[bucketIndex] += volume[i];
        }
        
        const pocIndex = volumeProfile.indexOf(Math.max(...volumeProfile));
        const poc = priceMin + (pocIndex + 0.5) * bucketSize;
        
        return {
            poc: poc,
            highVolume: volumeProfile.filter(v => v > volumeProfile.reduce((a, b) => a + b) / 20)
        };
    }

    function calculateRSI(prices, period = 14) {
        if (prices.length < period + 1) return null;
        
        let gains = 0;
        let losses = 0;
        
        for (let i = 1; i <= period; i++) {
            const change = prices[i] - prices[i - 1];
            if (change > 0) gains += change;
            else losses -= change;
        }
        
        let avgGain = gains / period;
        let avgLoss = losses / period;
        
        if (avgLoss === 0) return [100];
        
        const rsiValues = [100 - (100 / (1 + avgGain / avgLoss))];
        
        for (let i = period + 1; i < prices.length; i++) {
            const change = prices[i] - prices[i - 1];
            const gain = change > 0 ? change : 0;
            const loss = change < 0 ? -change : 0;
            
            avgGain = (avgGain * (period - 1) + gain) / period;
            avgLoss = (avgLoss * (period - 1) + loss) / period;
            
            if (avgLoss === 0) {
                rsiValues.push(100);
            } else {
                rsiValues.push(100 - (100 / (1 + avgGain / avgLoss)));
            }
        }
        
        return rsiValues;
    }

    function calculateEMA(values, period) {
        if (!values || values.length === 0) return [];
        const k = 2 / (period + 1);
        const ema = [values[0]];
        for (let i = 1; i < values.length; i++) {
            ema.push(values[i] * k + ema[i - 1] * (1 - k));
        }
        return ema;
    }

    function calculateLWMA(values, period) {
        if (!values || values.length < period) return [];
        const lwma = [];
        const denominator = (period * (period + 1)) / 2;
        for (let i = period - 1; i < values.length; i++) {
            let sum = 0;
            for (let j = 0; j < period; j++) {
                sum += values[i - j] * (period - j);
            }
            lwma.push(sum / denominator);
        }
        return lwma;
    }

    function calculateATR(high, low, close, period = 14) {
        const tr = [];
        for (let i = 1; i < high.length; i++) {
            const h_l = high[i] - low[i];
            const h_pc = Math.abs(high[i] - close[i - 1]);
            const l_pc = Math.abs(low[i] - close[i - 1]);
            tr.push(Math.max(h_l, h_pc, l_pc));
        }
        if (tr.length < period) return 10;
        let atr = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = period; i < tr.length; i++) {
            atr = (atr * (period - 1) + tr[i]) / period;
        }
        return atr;
    }

    // ==================== HELPER FUNCTIONS ====================

    function getIntervalSeconds(interval) {
        if (interval === 'D') return 86400;
        return parseInt(interval) * 60;
    }

    async function generateRealisticData(basePrice, interval, limit) {
        const prices = [];
        const high = [];
        const low = [];
        const timestamp = [];
        
        const intervalSeconds = getIntervalSeconds(interval);
        
        // Adjust volatility based on asset
        let baseVolatility = Math.sqrt(intervalSeconds / 60) * 2;
        if (currentAsset === 'BTCUSD') {
            baseVolatility *= 20; // Bitcoin is much more volatile
        }
        
        // IMPORTANT: Use basePrice parameter but verify it matches current asset
        const expectedPrice = assetConfig[currentAsset].basePrice;
        const actualBasePrice = (Math.abs(basePrice - expectedPrice) < expectedPrice * 0.5) ? basePrice : currentPrice;
        
        // Log to verify we're using correct base price
        console.log(`üìä Generating ${currentAsset} data: base=$${actualBasePrice.toFixed(2)}, volatility=${baseVolatility.toFixed(2)}`);
        
        let price = actualBasePrice * (0.98 + Math.random() * 0.04);
        
        for (let i = 0; i < limit; i++) {
            const progress = i / limit;
            const trendTowardsCurrent = (actualBasePrice - price) * 0.02;
            const cyclicalWave = Math.sin(i / 15) * baseVolatility * 0.5;
            const randomWalk = (Math.random() - 0.5) * baseVolatility;
            const momentum = (prices.length > 1) ? (prices[prices.length - 1] - prices[prices.length - 2]) * 0.3 : 0;
            
            price = price + trendTowardsCurrent + cyclicalWave + randomWalk + momentum;
            
            if (i >= limit - 3) {
                const convergence = 1 - (limit - i) / 3;
                price = price * (1 - convergence) + actualBasePrice * convergence;
            }
            
            if (i === limit - 1) {
                price = actualBasePrice;
            }
            
            const wickSize = baseVolatility * (0.3 + Math.random() * 0.3);
            const candleHigh = price + wickSize;
            const candleLow = price - wickSize;
            
            prices.push(price);
            high.push(candleHigh);
            low.push(candleLow);
            timestamp.push(Date.now() / 1000 - (limit - i) * intervalSeconds);
        }
        
        return { prices, high, low, timestamp };
    }

    async function fetchTradingViewData(interval, limit = 200) {
        // Always use the current price of the selected asset
        return await generateRealisticData(currentPrice, interval, limit);
    }

    // ==================== CONFLUENCE SCORING ====================

    function calculateConfluenceScore(indicators, signal) {
        let score = 0;
        let maxScore = 0;
        const details = [];
        
        maxScore += 15;
        if (signal === 'BUY') {
            if (indicators.rsi < 30) { score += 15; details.push('‚úì RSI Oversold'); }
            else if (indicators.rsi < 40) { score += 10; details.push('‚úì RSI Bullish'); }
            else if (indicators.rsi < 50) { score += 5; details.push('‚óã RSI Neutral+'); }
        } else if (signal === 'SELL') {
            if (indicators.rsi > 70) { score += 15; details.push('‚úì RSI Overbought'); }
            else if (indicators.rsi > 60) { score += 10; details.push('‚úì RSI Bearish'); }
            else if (indicators.rsi > 50) { score += 5; details.push('‚óã RSI Neutral-'); }
        }
        
        maxScore += 15;
        if (indicators.macdHistogram) {
            const currentHist = indicators.macdHistogram[indicators.macdHistogram.length - 1];
            const prevHist = indicators.macdHistogram[indicators.macdHistogram.length - 2];
            
            if (signal === 'BUY' && currentHist > 0 && currentHist > prevHist) {
                score += 15; details.push('‚úì MACD Bullish Cross');
            } else if (signal === 'SELL' && currentHist < 0 && currentHist < prevHist) {
                score += 15; details.push('‚úì MACD Bearish Cross');
            } else if ((signal === 'BUY' && currentHist > 0) || (signal === 'SELL' && currentHist < 0)) {
                score += 8; details.push('‚óã MACD Aligned');
            }
        }
        
        maxScore += 10;
        if (indicators.stochastic) {
            const k = indicators.stochastic.k[indicators.stochastic.k.length - 1];
            if (signal === 'BUY' && k < 20) { score += 10; details.push('‚úì Stoch Oversold'); }
            else if (signal === 'SELL' && k > 80) { score += 10; details.push('‚úì Stoch Overbought'); }
            else if ((signal === 'BUY' && k < 50) || (signal === 'SELL' && k > 50)) {
                score += 5; details.push('‚óã Stoch Aligned');
            }
        }
        
        maxScore += 10;
        if (indicators.bb) {
            const price = indicators.currentPrice;
            const upper = indicators.bb.upper[indicators.bb.upper.length - 1];
            const lower = indicators.bb.lower[indicators.bb.lower.length - 1];
            const middle = indicators.bb.middle[indicators.bb.middle.length - 1];
            
            if (signal === 'BUY' && price < lower) { score += 10; details.push('‚úì Price at BB Lower'); }
            else if (signal === 'SELL' && price > upper) { score += 10; details.push('‚úì Price at BB Upper'); }
            else if ((signal === 'BUY' && price < middle) || (signal === 'SELL' && price > middle)) {
                score += 5; details.push('‚óã BB Position OK');
            }
        }
        
        maxScore += 15;
        if (indicators.adx) {
            if (indicators.adx.adx > 25) {
                if (signal === 'BUY' && indicators.adx.plusDI > indicators.adx.minusDI) {
                    score += 15; details.push('‚úì Strong Uptrend (ADX)');
                } else if (signal === 'SELL' && indicators.adx.minusDI > indicators.adx.plusDI) {
                    score += 15; details.push('‚úì Strong Downtrend (ADX)');
                } else {
                    score += 8; details.push('‚óã Trending Market');
                }
            } else {
                details.push('‚ö† Weak Trend');
            }
        }
        
        maxScore += 10;
        if (indicators.cci) {
            const cci = indicators.cci[indicators.cci.length - 1];
            if (signal === 'BUY' && cci < -100) { score += 10; details.push('‚úì CCI Oversold'); }
            else if (signal === 'SELL' && cci > 100) { score += 10; details.push('‚úì CCI Overbought'); }
            else if ((signal === 'BUY' && cci < 0) || (signal === 'SELL' && cci > 0)) {
                score += 5; details.push('‚óã CCI Aligned');
            }
        }
        
        maxScore += 20;
        if (indicators.isCross) {
            score += 20; details.push('‚úì‚úì EMA/LWMA Cross!');
        } else if ((signal === 'BUY' && indicators.ema > indicators.lwma) || 
                  (signal === 'SELL' && indicators.ema < indicators.lwma)) {
            score += 10; details.push('‚úì EMA/LWMA Aligned');
        }
        
        maxScore += 10;
        if (indicators.volumeProfile) {
            const price = indicators.currentPrice;
            const poc = indicators.volumeProfile.poc;
            const distanceFromPOC = Math.abs(price - poc) / price;
            
            if (distanceFromPOC < 0.002) {
                score += 10; details.push('‚úì At Volume POC');
            } else if (distanceFromPOC < 0.005) {
                score += 5; details.push('‚óã Near Volume POC');
            }
        }
        
        const percentage = (score / maxScore) * 100;
        
        return {
            score: score,
            maxScore: maxScore,
            percentage: percentage.toFixed(1),
            details: details,
            quality: percentage >= 75 ? 'EXCELLENT' : 
                    percentage >= 60 ? 'GOOD' : 
                    percentage >= 45 ? 'MODERATE' : 'WEAK'
        };
    }

    // ==================== SMART ENTRY CALCULATION ====================
    
    function calculateSwingPoints(prices, lookback = 50) {
        const recentPrices = prices.slice(-lookback);
        const swingHigh = Math.max(...recentPrices);
        const swingLow = Math.min(...recentPrices);
        return { swingHigh, swingLow };
    }
    
    function calculateFibonacciLevels(swingHigh, swingLow, direction) {
        const range = swingHigh - swingLow;
        if (direction === 'BUY') {
            return {
                fib_236: swingLow + range * 0.236,
                fib_382: swingLow + range * 0.382,
                fib_500: swingLow + range * 0.500,
                fib_618: swingLow + range * 0.618,
                fib_786: swingLow + range * 0.786,
                fib_1000: swingHigh,
                fib_1272: swingHigh + range * 0.272,
                fib_1618: swingHigh + range * 0.618
            };
        } else {
            return {
                fib_236: swingHigh - range * 0.236,
                fib_382: swingHigh - range * 0.382,
                fib_500: swingHigh - range * 0.500,
                fib_618: swingHigh - range * 0.618,
                fib_786: swingHigh - range * 0.786,
                fib_1000: swingLow,
                fib_1272: swingLow - range * 0.272,
                fib_1618: swingLow - range * 0.618
            };
        }
    }
    
    function findSupportResistance(prices, currentPrice, tolerance = 0.002) {
        const levels = [];
        const priceRange = Math.max(...prices) - Math.min(...prices);
        const clusterTolerance = priceRange * tolerance;
        
        for (let i = 5; i < prices.length - 5; i++) {
            const isHigh = prices[i] > prices[i-1] && prices[i] > prices[i-2] && 
                          prices[i] > prices[i+1] && prices[i] > prices[i+2];
            const isLow = prices[i] < prices[i-1] && prices[i] < prices[i-2] && 
                         prices[i] < prices[i+1] && prices[i] < prices[i+2];
            
            if (isHigh || isLow) {
                levels.push(prices[i]);
            }
        }
        
        const clusteredLevels = [];
        levels.sort((a, b) => a - b);
        
        for (let level of levels) {
            const existing = clusteredLevels.find(l => Math.abs(l - level) < clusterTolerance);
            if (!existing) {
                clusteredLevels.push(level);
            }
        }
        
        const resistance = clusteredLevels.filter(l => l > currentPrice).sort((a, b) => a - b)[0];
        const support = clusteredLevels.filter(l => l < currentPrice).sort((a, b) => b - a)[0];
        
        return { support, resistance, allLevels: clusteredLevels };
    }

    function calculateSmartEntry(signal, currentMarketPrice, prices, rsiValues, atr, high, low, confluence) {
        if (signal === 'NEUTRAL') {
            return {
                marketEntry: currentMarketPrice,
                limitEntry: currentMarketPrice,
                stopEntry: currentMarketPrice,
                recommendedType: 'NONE',
                explanation: 'Kh√¥ng c√≥ t√≠n hi·ªáu r√µ r√†ng'
            };
        }

        const currentRSI = rsiValues[rsiValues.length - 1];
        const { swingHigh, swingLow } = calculateSwingPoints(prices);
        const srLevels = findSupportResistance(prices, currentMarketPrice);
        const ema20 = calculateEMA(prices, 20);
        const ema50 = calculateEMA(prices, 50);
        const currentEMA20 = ema20[ema20.length - 1];
        const currentEMA50 = ema50[ema50.length - 1];
        
        let marketEntry, limitEntry, stopEntry, recommendedType, explanation;

        if (signal === 'BUY') {
            marketEntry = currentMarketPrice;
            const limitCandidates = [];
            
            if (currentEMA20 < currentMarketPrice) limitCandidates.push({value: currentEMA20, weight: 2.0, name: 'EMA20 Pullback'});
            if (srLevels.support && srLevels.support < currentMarketPrice) limitCandidates.push({value: srLevels.support + (atr * 0.1), weight: 2.5, name: 'Support Zone'});
            
            const fibs = calculateFibonacciLevels(swingHigh, swingLow, 'BUY');
            if (fibs.fib_382 < currentMarketPrice) limitCandidates.push({value: fibs.fib_382, weight: 1.8, name: 'Fib 38.2%'});
            if (fibs.fib_500 < currentMarketPrice) limitCandidates.push({value: fibs.fib_500, weight: 1.5, name: 'Fib 50%'});
            if (swingLow < currentMarketPrice) limitCandidates.push({value: swingLow + (atr * 0.2), weight: 1.5, name: 'Swing Low'});
            limitCandidates.push({value: currentMarketPrice - (atr * 0.5), weight: 1.0, name: 'ATR 0.5x Pullback'});
            
            if (limitCandidates.length > 0) {
                let sumWeightedValues = 0, sumWeights = 0;
                limitCandidates.forEach(c => { sumWeightedValues += c.value * c.weight; sumWeights += c.weight; });
                limitEntry = sumWeightedValues / sumWeights;
            } else {
                limitEntry = currentMarketPrice - (atr * 0.5);
            }
            
            const stopCandidates = [];
            if (srLevels.resistance && srLevels.resistance > currentMarketPrice) stopCandidates.push({value: srLevels.resistance + (atr * 0.15), weight: 2.5, name: 'Resistance Break'});
            if (swingHigh > currentMarketPrice) stopCandidates.push({value: swingHigh + (atr * 0.1), weight: 2.0, name: 'Swing High Break'});
            if (currentEMA50 > currentMarketPrice) stopCandidates.push({value: currentEMA50 + (atr * 0.1), weight: 1.5, name: 'EMA50 Break'});
            stopCandidates.push({value: currentMarketPrice + (atr * 0.3), weight: 1.0, name: 'ATR Breakout'});
            
            if (stopCandidates.length > 0) {
                let sumWeightedValues = 0, sumWeights = 0;
                stopCandidates.forEach(c => { sumWeightedValues += c.value * c.weight; sumWeights += c.weight; });
                stopEntry = sumWeightedValues / sumWeights;
            } else {
                stopEntry = currentMarketPrice + (atr * 0.3);
            }
            
            const confluenceScore = parseFloat(confluence.percentage);
            if (confluenceScore >= 70 && currentRSI < 35) {
                recommendedType = 'MARKET'; explanation = 'T√≠n hi·ªáu m·∫°nh + RSI qu√° b√°n ‚Üí V√†o ngay';
            } else if (currentMarketPrice > currentEMA20 * 1.003) {
                recommendedType = 'LIMIT'; explanation = 'Gi√° ƒë√£ ch·∫°y xa EMA ‚Üí Ch·ªù pullback';
            } else if (srLevels.resistance && Math.abs(currentMarketPrice - srLevels.resistance) < atr * 0.3) {
                recommendedType = 'STOP'; explanation = 'G·∫ßn kh√°ng c·ª± ‚Üí Ch·ªù ph√° v√πng x√°c nh·∫≠n';
            } else if (confluenceScore >= 60) {
                recommendedType = 'MARKET'; explanation = 'Confluence t·ªët ‚Üí C√≥ th·ªÉ v√†o ngay';
            } else {
                recommendedType = 'LIMIT'; explanation = 'T√≠n hi·ªáu trung b√¨nh ‚Üí Ch·ªù gi√° t·ªët h∆°n';
            }

        } else {
            marketEntry = currentMarketPrice;
            const limitCandidates = [];
            
            if (currentEMA20 > currentMarketPrice) limitCandidates.push({value: currentEMA20, weight: 2.0, name: 'EMA20 Rally'});
            if (srLevels.resistance && srLevels.resistance > currentMarketPrice) limitCandidates.push({value: srLevels.resistance - (atr * 0.1), weight: 2.5, name: 'Resistance Zone'});
            
            const fibs = calculateFibonacciLevels(swingHigh, swingLow, 'SELL');
            if (fibs.fib_382 > currentMarketPrice) limitCandidates.push({value: fibs.fib_382, weight: 1.8, name: 'Fib 38.2%'});
            if (fibs.fib_500 > currentMarketPrice) limitCandidates.push({value: fibs.fib_500, weight: 1.5, name: 'Fib 50%'});
            if (swingHigh > currentMarketPrice) limitCandidates.push({value: swingHigh - (atr * 0.2), weight: 1.5, name: 'Swing High'});
            limitCandidates.push({value: currentMarketPrice + (atr * 0.5), weight: 1.0, name: 'ATR 0.5x Rally'});
            
            if (limitCandidates.length > 0) {
                let sumWeightedValues = 0, sumWeights = 0;
                limitCandidates.forEach(c => { sumWeightedValues += c.value * c.weight; sumWeights += c.weight; });
                limitEntry = sumWeightedValues / sumWeights;
            } else {
                limitEntry = currentMarketPrice + (atr * 0.5);
            }
            
            const stopCandidates = [];
            if (srLevels.support && srLevels.support < currentMarketPrice) stopCandidates.push({value: srLevels.support - (atr * 0.15), weight: 2.5, name: 'Support Break'});
            if (swingLow < currentMarketPrice) stopCandidates.push({value: swingLow - (atr * 0.1), weight: 2.0, name: 'Swing Low Break'});
            if (currentEMA50 < currentMarketPrice) stopCandidates.push({value: currentEMA50 - (atr * 0.1), weight: 1.5, name: 'EMA50 Break'});
            stopCandidates.push({value: currentMarketPrice - (atr * 0.3), weight: 1.0, name: 'ATR Breakdown'});
            
            if (stopCandidates.length > 0) {
                let sumWeightedValues = 0, sumWeights = 0;
                stopCandidates.forEach(c => { sumWeightedValues += c.value * c.weight; sumWeights += c.weight; });
                stopEntry = sumWeightedValues / sumWeights;
            } else {
                stopEntry = currentMarketPrice - (atr * 0.3);
            }
            
            const confluenceScore = parseFloat(confluence.percentage);
            if (confluenceScore >= 70 && currentRSI > 65) {
                recommendedType = 'MARKET'; explanation = 'T√≠n hi·ªáu m·∫°nh + RSI qu√° mua ‚Üí V√†o ngay';
            } else if (currentMarketPrice < currentEMA20 * 0.997) {
                recommendedType = 'LIMIT'; explanation = 'Gi√° ƒë√£ ch·∫°y xa EMA ‚Üí Ch·ªù rally';
            } else if (srLevels.support && Math.abs(currentMarketPrice - srLevels.support) < atr * 0.3) {
                recommendedType = 'STOP'; explanation = 'G·∫ßn h·ªó tr·ª£ ‚Üí Ch·ªù ph√° v√πng x√°c nh·∫≠n';
            } else if (confluenceScore >= 60) {
                recommendedType = 'MARKET'; explanation = 'Confluence t·ªët ‚Üí C√≥ th·ªÉ v√†o ngay';
            } else {
                recommendedType = 'LIMIT'; explanation = 'T√≠n hi·ªáu trung b√¨nh ‚Üí Ch·ªù gi√° t·ªët h∆°n';
            }
        }

        return { marketEntry, limitEntry, stopEntry, recommendedType, explanation };
    }

    // ==================== TP/SL CALCULATION ====================
    
    function calculateAdvancedTPSL(signal, entryPrice, entryType, prices, rsiValues, atr, high, low) {
        if (signal === 'NEUTRAL') {
            return { tp: entryPrice, sl: entryPrice, rrRatio: '0.00', tpMethods: 'N/A', slMethods: 'N/A', tpCount: 0, slCount: 0 };
        }
        
        const currentRSI = rsiValues[rsiValues.length - 1];
        const { swingHigh, swingLow } = calculateSwingPoints(prices);
        const srLevels = findSupportResistance(prices, entryPrice);
        
        let tpCandidates = [];
        let slCandidates = [];
        
        let tpMultiplier = 1.0;
        let slMultiplier = 1.0;
        
        if (entryType === 'MARKET') {
            tpMultiplier = 1.0; slMultiplier = 1.2;
        } else if (entryType === 'LIMIT') {
            tpMultiplier = 1.3; slMultiplier = 0.8;
        } else if (entryType === 'STOP') {
            tpMultiplier = 1.5; slMultiplier = 0.7;
        }
        
        if (signal === 'BUY') {
            tpCandidates.push({ value: entryPrice + (atr * 2 * tpMultiplier), weight: 1.0, name: 'ATR 2x' });
            slCandidates.push({ value: entryPrice - (atr * 1 * slMultiplier), weight: 1.0, name: 'ATR 1x' });
            
            if (currentRSI < 30) {
                const rsiTarget = entryPrice * 1.015 * tpMultiplier;
                tpCandidates.push({ value: rsiTarget, weight: 1.5, name: 'RSI Target 70' });
                slCandidates.push({ value: entryPrice * (1 - 0.005 * slMultiplier), weight: 1.2, name: 'RSI SL' });
            } else if (currentRSI < 50) {
                tpCandidates.push({ value: entryPrice * (1 + 0.01 * tpMultiplier), weight: 1.2, name: 'RSI Target 60' });
                slCandidates.push({ value: entryPrice * (1 - 0.003 * slMultiplier), weight: 1.0, name: 'RSI SL' });
            }
            
            const fibs = calculateFibonacciLevels(swingHigh, swingLow, 'BUY');
            if (fibs.fib_1618 > entryPrice) tpCandidates.push({ value: fibs.fib_1618, weight: 1.3 * tpMultiplier, name: 'Fib 161.8%' });
            if (fibs.fib_1272 > entryPrice) tpCandidates.push({ value: fibs.fib_1272, weight: 1.2 * tpMultiplier, name: 'Fib 127.2%' });
            if (fibs.fib_382 < entryPrice) slCandidates.push({ value: fibs.fib_382, weight: 1.1 * slMultiplier, name: 'Fib 38.2% SL' });
            
            if (srLevels.resistance && srLevels.resistance > entryPrice) {
                const distanceToR = srLevels.resistance - entryPrice;
                if (distanceToR > atr * 0.5) tpCandidates.push({ value: srLevels.resistance - (atr * 0.2), weight: 2.0 * tpMultiplier, name: 'Resistance' });
            }
            if (srLevels.support && srLevels.support < entryPrice) slCandidates.push({ value: srLevels.support - (atr * 0.1), weight: 2.0 * slMultiplier, name: 'Support' });
            if (swingHigh > entryPrice) tpCandidates.push({ value: swingHigh, weight: 1.5 * tpMultiplier, name: 'Swing High' });
            slCandidates.push({ value: swingLow - (atr * 0.2), weight: 1.3 * slMultiplier, name: 'Swing Low' });
            
        } else if (signal === 'SELL') {
            tpCandidates.push({ value: entryPrice - (atr * 2 * tpMultiplier), weight: 1.0, name: 'ATR 2x' });
            slCandidates.push({ value: entryPrice + (atr * 1 * slMultiplier), weight: 1.0, name: 'ATR 1x' });
            
            if (currentRSI > 70) {
                const rsiTarget = entryPrice * (1 - 0.015 * tpMultiplier);
                tpCandidates.push({ value: rsiTarget, weight: 1.5, name: 'RSI Target 30' });
                slCandidates.push({ value: entryPrice * (1 + 0.005 * slMultiplier), weight: 1.2, name: 'RSI SL' });
            } else if (currentRSI > 50) {
                tpCandidates.push({ value: entryPrice * (1 - 0.01 * tpMultiplier), weight: 1.2, name: 'RSI Target 40' });
                slCandidates.push({ value: entryPrice * (1 + 0.003 * slMultiplier), weight: 1.0, name: 'RSI SL' });
            }
            
            const fibs = calculateFibonacciLevels(swingHigh, swingLow, 'SELL');
            if (fibs.fib_1618 < entryPrice) tpCandidates.push({ value: fibs.fib_1618, weight: 1.3 * tpMultiplier, name: 'Fib 161.8%' });
            if (fibs.fib_1272 < entryPrice) tpCandidates.push({ value: fibs.fib_1272, weight: 1.2 * tpMultiplier, name: 'Fib 127.2%' });
            if (fibs.fib_382 > entryPrice) slCandidates.push({ value: fibs.fib_382, weight: 1.1 * slMultiplier, name: 'Fib 38.2% SL' });
            
            if (srLevels.support && srLevels.support < entryPrice) {
                const distanceToS = entryPrice - srLevels.support;
                if (distanceToS > atr * 0.5) tpCandidates.push({ value: srLevels.support + (atr * 0.2), weight: 2.0 * tpMultiplier, name: 'Support' });
            }
            if (srLevels.resistance && srLevels.resistance > entryPrice) slCandidates.push({ value: srLevels.resistance + (atr * 0.1), weight: 2.0 * slMultiplier, name: 'Resistance' });
            if (swingLow < entryPrice) tpCandidates.push({ value: swingLow, weight: 1.5 * tpMultiplier, name: 'Swing Low' });
            slCandidates.push({ value: swingHigh + (atr * 0.2), weight: 1.3 * slMultiplier, name: 'Swing High' });
        }
        
        const calculateWeightedAverage = (candidates) => {
            if (candidates.length === 0) return null;
            let sumWeightedValues = 0, sumWeights = 0;
            candidates.forEach(c => { sumWeightedValues += c.value * c.weight; sumWeights += c.weight; });
            return sumWeightedValues / sumWeights;
        };
        
        const tp = calculateWeightedAverage(tpCandidates);
        const sl = calculateWeightedAverage(slCandidates);
        
        const tpMethods = tpCandidates.map(c => c.name).join(', ');
        const slMethods = slCandidates.map(c => c.name).join(', ');
        
        let finalTP = tp;
        let finalSL = sl;
        
        const risk = Math.abs(entryPrice - sl);
        const reward = Math.abs(tp - entryPrice);
        const rrRatio = reward / risk;
        
        if (rrRatio < 1.5) {
            if (signal === 'BUY') finalTP = entryPrice + (risk * 2);
            else finalTP = entryPrice - (risk * 2);
        }
        
        return {
            tp: finalTP,
            sl: finalSL,
            rrRatio: ((Math.abs(finalTP - entryPrice)) / Math.abs(entryPrice - finalSL)).toFixed(2),
            tpMethods: tpMethods,
            slMethods: slMethods,
            tpCount: tpCandidates.length,
            slCount: slCandidates.length
        };
    }

    // ==================== MAIN ANALYSIS ====================

    async function analyzeTimeframe(tf) {
        // Always get fresh data for current asset
        const data = await fetchTradingViewData(tf.interval);
        const prices = data.prices;
        
        const rsiValues = calculateRSI(prices, 14);
        if (!rsiValues || rsiValues.length < 50) return null;
        
        const emaOnRsi = calculateEMA(rsiValues, 9);
        const lwmaOnRsi = calculateLWMA(rsiValues, 45);
        if (lwmaOnRsi.length === 0) return null;
        
        const currentRSI = rsiValues[rsiValues.length - 1];
        const currentEMA = emaOnRsi[emaOnRsi.length - 1];
        const currentLWMA = lwmaOnRsi[lwmaOnRsi.length - 1];
        const prevEMA = emaOnRsi[emaOnRsi.length - 2];
        const prevLWMA = lwmaOnRsi[lwmaOnRsi.length - 2];
        
        const macd = calculateMACD(prices);
        const bb = calculateBollingerBands(prices);
        const stochastic = calculateStochastic(data.high, data.low, prices);
        const adx = calculateADX(data.high, data.low, prices);
        const cci = calculateCCI(data.high, data.low, prices);
        const volumeProfile = detectVolumeProfile(prices);
        
        let signal = 'NEUTRAL';
        let signalStrength = 0;
        
        const emaCrossAbove = prevEMA <= prevLWMA && currentEMA > currentLWMA;
        const emaCrossBelow = prevEMA >= prevLWMA && currentEMA < currentLWMA;
        
        if (emaCrossAbove) {
            signal = 'BUY';
            signalStrength = Math.abs(currentEMA - currentLWMA);
        } else if (emaCrossBelow) {
            signal = 'SELL';
            signalStrength = Math.abs(currentEMA - currentLWMA);
        } else {
            if (currentEMA > currentLWMA) {
                signal = 'BUY';
                signalStrength = (currentEMA - currentLWMA) * 0.5;
            } else if (currentEMA < currentLWMA) {
                signal = 'SELL';
                signalStrength = (currentLWMA - currentEMA) * 0.5;
            }
        }
        
        // Use the LAST price from generated data as current market price
        // This ensures consistency between price display and analysis
        const currentMarketPrice = prices[prices.length - 1];
        const atr = calculateATR(data.high, data.low, prices, 14);
        
        const indicators = {
            rsi: currentRSI, ema: currentEMA, lwma: currentLWMA,
            isCross: emaCrossAbove || emaCrossBelow,
            macdHistogram: macd.histogram, bb: bb, stochastic: stochastic,
            adx: adx, cci: cci, volumeProfile: volumeProfile,
            currentPrice: currentMarketPrice
        };
        
        const confluence = calculateConfluenceScore(indicators, signal);
        const entryData = calculateSmartEntry(signal, currentMarketPrice, prices, rsiValues, atr, data.high, data.low, confluence);
        
        const marketTPSL = calculateAdvancedTPSL(signal, entryData.marketEntry, 'MARKET', prices, rsiValues, atr, data.high, data.low);
        const limitTPSL = calculateAdvancedTPSL(signal, entryData.limitEntry, 'LIMIT', prices, rsiValues, atr, data.high, data.low);
        const stopTPSL = calculateAdvancedTPSL(signal, entryData.stopEntry, 'STOP', prices, rsiValues, atr, data.high, data.low);
        
        return {
            timeframe: tf.label,
            rsi: currentRSI.toFixed(2), ema: currentEMA.toFixed(2), lwma: currentLWMA.toFixed(2),
            macd: macd.histogram[macd.histogram.length - 1].toFixed(4),
            stoch: stochastic.k[stochastic.k.length - 1].toFixed(2),
            adxValue: adx.adx.toFixed(2), cci: cci[cci.length - 1].toFixed(2),
            signal: signal, signalStrength: signalStrength, confluence: confluence,
            currentPrice: currentMarketPrice.toFixed(assetConfig[currentAsset].priceDecimals),
            entryData: entryData, marketTPSL: marketTPSL, limitTPSL: limitTPSL, stopTPSL: stopTPSL,
            isCross: emaCrossAbove || emaCrossBelow
        };
    }

    async function analyzeMarket() {
        document.getElementById('loadingIndicator').style.display = 'block';
        document.getElementById('analysisGrid').innerHTML = '';
        document.getElementById('summarySection').style.display = 'none';
        
        // Log which asset we're analyzing
        console.log(`üîç Analyzing ${currentAsset} at price: $${currentPrice.toFixed(2)}`);
        
        const results = [];
        
        for (const tf of timeframes) {
            const analysis = await analyzeTimeframe(tf);
            if (analysis) {
                results.push(analysis);
                displayTimeframeAnalysis(analysis);
            }
        }
        
        displaySummary(results);
        
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('lastUpdate').textContent = `Ph√¢n t√≠ch l·∫ßn cu·ªëi: ${new Date().toLocaleString('vi-VN')}`;
    }

    function displayTimeframeAnalysis(analysis) {
        const grid = document.getElementById('analysisGrid');
        const card = document.createElement('div');
        card.className = 'timeframe-card';
        
        const signalClass = analysis.signal.toLowerCase();
        const signalIcon = analysis.signal === 'BUY' ? 'üìà' : analysis.signal === 'SELL' ? 'üìâ' : '‚ûñ';
        const crossIndicator = analysis.isCross ? ' üî• (C·∫ÆT NHAU!)' : '';
        
        const confluence = analysis.confluence;
        const strengthClass = confluence.percentage >= 60 ? 'strong' : confluence.percentage >= 45 ? 'medium' : 'weak';
        
        const recommendedEntry = analysis.entryData.recommendedType;
        let recommendedTPSL, otherEntries;
        
        if (recommendedEntry === 'MARKET') {
            recommendedTPSL = analysis.marketTPSL;
            otherEntries = [
                { type: 'LIMIT', entry: analysis.entryData.limitEntry, tpsl: analysis.limitTPSL },
                { type: 'STOP', entry: analysis.entryData.stopEntry, tpsl: analysis.stopTPSL }
            ];
        } else if (recommendedEntry === 'LIMIT') {
            recommendedTPSL = analysis.limitTPSL;
            otherEntries = [
                { type: 'MARKET', entry: analysis.entryData.marketEntry, tpsl: analysis.marketTPSL },
                { type: 'STOP', entry: analysis.entryData.stopEntry, tpsl: analysis.stopTPSL }
            ];
        } else {
            recommendedTPSL = analysis.stopTPSL;
            otherEntries = [
                { type: 'MARKET', entry: analysis.entryData.marketEntry, tpsl: analysis.marketTPSL },
                { type: 'LIMIT', entry: analysis.entryData.limitEntry, tpsl: analysis.limitTPSL }
            ];
        }
        
        const decimals = assetConfig[currentAsset].priceDecimals;
        const recommendedEntryPrice = recommendedEntry === 'MARKET' ? analysis.entryData.marketEntry : recommendedEntry === 'LIMIT' ? analysis.entryData.limitEntry : analysis.entryData.stopEntry;
        
        const tp = parseFloat(recommendedTPSL.tp);
        const sl = parseFloat(recommendedTPSL.sl);
        const tpPips = Math.abs(tp - recommendedEntryPrice).toFixed(decimals);
        const slPips = Math.abs(sl - recommendedEntryPrice).toFixed(decimals);
        const tpPercent = ((Math.abs(tp - recommendedEntryPrice) / recommendedEntryPrice) * 100).toFixed(2);
        const slPercent = ((Math.abs(sl - recommendedEntryPrice) / recommendedEntryPrice) * 100).toFixed(2);
        
        card.innerHTML = `
            <div class="timeframe-header">${analysis.timeframe}</div>
            <div class="confluence-score">
                <div style="font-size: 0.9em; opacity: 0.9;">Confluence Score</div>
                <div class="score-value">${confluence.percentage}%</div>
                <div style="font-size: 1.1em; margin-top: 5px;">${confluence.quality}</div>
                <div class="confluence-details">${confluence.score}/${confluence.maxScore} points</div>
            </div>
            <div class="indicator-values">
                <div class="indicator-row"><span class="indicator-label">RSI(14):</span><span class="indicator-value">${analysis.rsi}</span></div>
                <div class="indicator-row"><span class="indicator-label">EMA(9) on RSI:</span><span class="indicator-value">${analysis.ema}</span></div>
                <div class="indicator-row"><span class="indicator-label">LWMA(45) on RSI:</span><span class="indicator-value">${analysis.lwma}</span></div>
                <div class="indicator-row"><span class="indicator-label">MACD Histogram:</span><span class="indicator-value">${analysis.macd}</span></div>
                <div class="indicator-row"><span class="indicator-label">Stochastic:</span><span class="indicator-value">${analysis.stoch}</span></div>
                <div class="indicator-row"><span class="indicator-label">ADX:</span><span class="indicator-value">${analysis.adxValue}</span></div>
                <div class="indicator-row"><span class="indicator-label">CCI:</span><span class="indicator-value">${analysis.cci}</span></div>
            </div>
            <div class="signal-strength-bar">
                <div class="strength-label">Signal Strength:</div>
                <div class="strength-bar">
                    <div class="strength-fill ${strengthClass}" style="width: ${confluence.percentage}%">${confluence.percentage}%</div>
                </div>
            </div>
            <div class="signal ${signalClass}">${signalIcon} ${analysis.signal}${crossIndicator}</div>
            <div style="margin-top: 15px; padding: 12px; background: #f0f8ff; border-radius: 8px; font-size: 0.85em;">
                <strong>‚úì Indicators Aligned:</strong>
                <div style="margin-top: 8px; line-height: 1.6;">${confluence.details.map(d => `<div>${d}</div>`).join('')}</div>
            </div>
            <div class="trade-levels">
                <div class="level-row current"><span>üí∞ Gi√° hi·ªán t·∫°i:</span><span>$${analysis.currentPrice}</span></div>
                <div class="level-row entry-${recommendedEntry.toLowerCase()}" style="background: #fffbea; border-left: 4px solid #f39c12;">
                    <span>üìç Entry ƒê·ªÅ Xu·∫•t: <span class="entry-type-badge badge-${recommendedEntry.toLowerCase()}">${recommendedEntry}</span></span>
                    <span>$${recommendedEntryPrice.toFixed(decimals)}</span>
                </div>
                <div class="entry-explanation"><strong>üí° ${analysis.entryData.explanation}</strong></div>
                <div class="level-row tp"><span>üéØ TP (${recommendedEntry}):</span><span>$${tp.toFixed(decimals)} (+${tpPips} / ${tpPercent}%)</span></div>
                <div class="level-row sl"><span>üõë SL (${recommendedEntry}):</span><span>$${sl.toFixed(decimals)} (-${slPips} / ${slPercent}%)</span></div>
                <div class="indicator-row" style="margin-top: 10px; background: #fff3cd; border-left: 4px solid #ffc107;">
                    <span class="indicator-label">‚öñÔ∏è R:R Ratio:</span>
                    <span class="indicator-value" style="color: #856404; font-size: 1.1em;">1:${recommendedTPSL.rrRatio}</span>
                </div>
            </div>
            <div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 0.8em;">
                <strong>üìå Entry Alternatives:</strong>
                ${otherEntries.map(alt => {
                    const altTP = parseFloat(alt.tpsl.tp);
                    const altSL = parseFloat(alt.tpsl.sl);
                    const altEntryPrice = parseFloat(alt.entry);
                    const altTPPips = Math.abs(altTP - altEntryPrice).toFixed(decimals);
                    const altSLPips = Math.abs(altSL - altEntryPrice).toFixed(decimals);
                    return `<div style="margin: 10px 0; padding: 10px; background: white; border-radius: 6px; border-left: 3px solid #dee2e6;">
                        <div style="font-weight: 600; margin-bottom: 5px;">
                            <span class="entry-type-badge badge-${alt.type.toLowerCase()}">${alt.type}</span>
                            Entry: $${altEntryPrice.toFixed(decimals)}
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.9em;">
                            <span>TP: $${altTP.toFixed(decimals)} (+${altTPPips})</span>
                            <span>SL: $${altSL.toFixed(decimals)} (-${altSLPips})</span>
                            <span>R:R 1:${alt.tpsl.rrRatio}</span>
                        </div>
                    </div>`;
                }).join('')}
            </div>
            <div style="margin-top: 15px; padding: 12px; background: #e7f3ff; border-radius: 8px; font-size: 0.85em;">
                <div style="margin-bottom: 8px;"><strong>üéØ TP Methods (${recommendedTPSL.tpCount}):</strong>
                    <div style="color: #0066cc; margin-top: 4px;">${recommendedTPSL.tpMethods || 'ATR-based'}</div>
                </div>
                <div><strong>üõë SL Methods (${recommendedTPSL.slCount}):</strong>
                    <div style="color: #cc0000; margin-top: 4px;">${recommendedTPSL.slMethods || 'ATR-based'}</div>
                </div>
            </div>
        `;
        
        grid.appendChild(card);
    }

    function displaySummary(results) {
        const buyCount = results.filter(r => r.signal === 'BUY').length;
        const sellCount = results.filter(r => r.signal === 'SELL').length;
        const neutralCount = results.filter(r => r.signal === 'NEUTRAL').length;
        
        const avgConfluence = results.reduce((sum, r) => sum + parseFloat(r.confluence.percentage), 0) / results.length;
        const strongSignals = results.filter(r => parseFloat(r.confluence.percentage) >= 60).length;
        
        let overallSignal = 'NEUTRAL';
        if (buyCount > sellCount + neutralCount) overallSignal = 'BUY';
        else if (sellCount > buyCount + neutralCount) overallSignal = 'SELL';
        
        const summaryContent = document.getElementById('summaryContent');
        summaryContent.innerHTML = `
            <p><strong>Asset:</strong> ${assetConfig[currentAsset].symbol} (${assetConfig[currentAsset].name})</p>
            <p><strong>T·ªïng s·ªë khung ph√¢n t√≠ch:</strong> ${results.length}</p>
            <p><strong>üìà T√≠n hi·ªáu BUY:</strong> ${buyCount} khung</p>
            <p><strong>üìâ T√≠n hi·ªáu SELL:</strong> ${sellCount} khung</p>
            <p><strong>‚ûñ T√≠n hi·ªáu NEUTRAL:</strong> ${neutralCount} khung</p>
            <p><strong>üí™ T√≠n hi·ªáu m·∫°nh (‚â•60%):</strong> ${strongSignals} khung</p>
            <p><strong>üìä ƒê·ªô ch√≠nh x√°c trung b√¨nh:</strong> ${avgConfluence.toFixed(1)}%</p>
            <p style="margin-top: 15px; font-size: 1.2em;"><strong>üéØ Xu h∆∞·ªõng chung: ${overallSignal}</strong></p>
            <p style="margin-top: 10px; font-size: 0.95em; opacity: 0.9;">
                ${overallSignal === 'BUY' ? '‚úÖ ƒêa s·ªë khung th·ªùi gian ƒëang c√≥ xu h∆∞·ªõng tƒÉng' :
                  overallSignal === 'SELL' ? '‚ö†Ô∏è ƒêa s·ªë khung th·ªùi gian ƒëang c√≥ xu h∆∞·ªõng gi·∫£m' :
                  '‚öñÔ∏è Th·ªã tr∆∞·ªùng ƒëang trong tr·∫°ng th√°i trung l·∫≠p'}
            </p>
            <p style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.2); border-radius: 8px;">
                <strong>üí° H∆∞·ªõng d·∫´n Entry:</strong><br>
                ‚Ä¢ <strong>MARKET</strong> = V√†o ngay (t√≠n hi·ªáu m·∫°nh)<br>
                ‚Ä¢ <strong>LIMIT</strong> = Ch·ªù gi√° pullback (entry t·ªët h∆°n)<br>
                ‚Ä¢ <strong>STOP</strong> = Ch·ªù ph√° v√πng x√°c nh·∫≠n (breakout)
            </p>
        `;
        
        document.getElementById('summarySection').style.display = 'block';
    }

    function toggleAutoRefresh() {
        isAutoRefreshEnabled = !isAutoRefreshEnabled;
        const btn = document.getElementById('autoRefreshBtn');
        
        if (isAutoRefreshEnabled) {
            btn.innerHTML = '‚è∏Ô∏è T·∫°m d·ª´ng';
            startAutoRefresh();
        } else {
            btn.innerHTML = '‚ñ∂Ô∏è Ti·∫øp t·ª•c';
            stopAutoRefresh();
        }
    }

    function startAutoRefresh() {
        priceInterval = setInterval(updatePriceRealtime, 1000);
        analysisInterval = setInterval(analyzeMarket, 30000);
    }

    function stopAutoRefresh() {
        if (priceInterval) clearInterval(priceInterval);
        if (analysisInterval) clearInterval(analysisInterval);
    }

    window.onload = async function() {
        await updatePriceRealtime();
        await analyzeMarket();
        startAutoRefresh();
    };

    window.onbeforeunload = function() {
        stopAutoRefresh();
    };
</script>

</body>
</html>
